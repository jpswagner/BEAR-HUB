# BACTOPIA-TOOLS.py ‚Äî Bactopia Local UI (Official tools via --wf)
# ---------------------------------------------------------------------
# ‚Ä¢ Streamlit interface to orchestrate **Bactopia Tools** (via Nextflow `--wf`)
# ‚Ä¢ Focused on results already generated by Bactopia (folder with samples)
# ‚Ä¢ Allows batch execution of official tools such as:
#     - amrfinderplus, rgi, abricate, mobsuite, mlst
#     - pangenome (Panaroo/PIRATE/Roary + IQ-TREE + Prokka + Scoary + SNP-dists)
#     - mashtree, plasmidfinder
# ‚Ä¢ Asynchronous execution with log tailing (Nextflow)
# ‚Ä¢ Optional integration with the Bactopia conda environment via BACTOPIA_ENV_PREFIX
# ‚Ä¢ Can be used standalone:
#       streamlit run BACTOPIA-TOOLS.py
#   or as a page inside BEAR-HUB.
#
# ‚ö†Ô∏è Important notice:
#   - **Bactopia** is developed by third parties (community/open source).
#   - **BEAR-HUB** only assembles and runs Nextflow/Bactopia commands
#     in a friendlier way, without modifying the pipeline code.
#   - Always refer to the official Bactopia documentation for methods,
#     limitations, and the correct way to cite the software.
# ---------------------------------------------------------------------

"""
Bactopia Tools Interface.

This module provides a UI for running "Bactopia Tools" (workflows that run on
already processed Bactopia samples). It handles:
1.  **Sample Discovery**: Scanning a Bactopia output directory to find valid samples.
2.  **Tool Selection**: Checkbox-based selection of tools like AMRFinderPlus, RGI, MLST, etc.
3.  **Configuration**: Setting parameters specific to each tool (e.g., identity thresholds, database paths).
4.  **Batch Execution**: Creating an `--include` file for selected samples and running the tools via Nextflow.
5.  **Monitoring**: Real-time log visualization.
"""

import os
import shlex
import time
import pathlib
import subprocess
import re
import shutil
import asyncio
import html
import threading
import hashlib
import fnmatch
from typing import List
from queue import Queue, Empty

import streamlit as st
import streamlit.components.v1 as components

# ============================= General config =============================
st.set_page_config(
    page_title="Bactopia ‚Äî Tools | BEAR-HUB",
    page_icon="üêª",
    layout="wide",
)

APP_ROOT = pathlib.Path(__file__).resolve().parent
PAGES_DIR = APP_ROOT / "pages"
PAGE_BACTOPIA = PAGES_DIR / "BACTOPIA.py"
PAGE_TOOLS = PAGES_DIR / "BACTOPIA-TOOLS.py"
PAGE_MERLIN = PAGES_DIR / "MERLIN.py"
PAGE_PORT = PAGES_DIR / "PORT.py"

# Safely discover project root
if (APP_ROOT / "static").is_dir():
    PROJECT_ROOT = APP_ROOT
elif (APP_ROOT.parent / "static").is_dir():
    PROJECT_ROOT = APP_ROOT.parent
else:
    PROJECT_ROOT = APP_ROOT  # fallback

def _st_rerun():
    """
    Trigger a rerun of the Streamlit script.

    Uses `st.rerun()` if available, otherwise `st.experimental_rerun()`.
    """
    fn = getattr(st, "rerun", None) or getattr(st, "experimental_rerun", None)
    if fn:
        fn()

APP_STATE_DIR = pathlib.Path.home() / ".bactopia_ui_local"

# Default outdir aligned with BEAR-HUB (can be overridden by bt_outdir from main page)
DEFAULT_OUTDIR = str((pathlib.Path.home() / "BEAR_DATA" / "bactopia_out").resolve())

# ===================== Nextflow via Bactopia environment =====================

def bootstrap_bear_env_from_file():
    """
    Load environment variables from `.bear-hub.env`.

    Reads configuration if not already present in the environment. Sets:
      - BEAR_HUB_ROOT
      - BEAR_HUB_BASEDIR
      - BACTOPIA_ENV_PREFIX
      - NXF_CONDA_EXE
    """
    solver = os.environ.get("NXF_CONDA_EXE")
    if os.environ.get("BACTOPIA_ENV_PREFIX") and solver and os.path.exists(solver):
        return

    candidates: list[pathlib.Path] = []

    # If BEAR_HUB_ROOT is already defined, use it as starting point
    env_root = os.environ.get("BEAR_HUB_ROOT")
    if env_root:
        candidates.append(pathlib.Path(env_root).expanduser() / ".bear-hub.env")

    # Default BEAR-HUB install location fallback
    candidates.append(pathlib.Path.home() / "BEAR-HUB" / ".bear-hub.env")

    for cfg in candidates:
        try:
            if not cfg.is_file():
                continue
            with cfg.open("r", encoding="utf-8") as fh:
                for line in fh:
                    line = line.strip()
                    if not line or line.startswith("#"):
                        continue
                    m = re.match(r'export\s+([A-Za-z_][A-Za-z0-9_]*)=(.*)', line)
                    if not m:
                        continue
                    var, value = m.group(1), m.group(2).strip()
                    # remove single/double quotes if line is export VAR="..."
                    if ((value.startswith('"') and value.endswith('"'))
                            or (value.startswith("'") and value.endswith("'"))):
                        value = value[1:-1]
                    if not var or not value:
                        continue

                    if var == "NXF_CONDA_EXE":
                        cur = os.environ.get("NXF_CONDA_EXE")
                        if (not cur) or (cur and not os.path.exists(cur)):
                            os.environ["NXF_CONDA_EXE"] = value
                    else:
                        if var not in os.environ:
                            os.environ[var] = value
            break
        except Exception:
            continue

    if os.environ.get("BEAR_HUB_ROOT") and not os.environ.get("BEAR_HUB_BASEDIR"):
        os.environ["BEAR_HUB_BASEDIR"] = os.environ["BEAR_HUB_ROOT"]


# Try to load .bear-hub.env right at startup
bootstrap_bear_env_from_file()

# Discover Nextflow from the 'bactopia' environment, if it exists
BACTOPIA_ENV_PREFIX = os.environ.get("BACTOPIA_ENV_PREFIX")
BACTOPIA_NEXTFLOW_BIN: str | None = None

if BACTOPIA_ENV_PREFIX:
    try:
        _bact_env = pathlib.Path(BACTOPIA_ENV_PREFIX).expanduser().resolve()
        _cand_nf = _bact_env / "bin" / "nextflow"
        if _cand_nf.is_file() and os.access(_cand_nf, os.X_OK):
            BACTOPIA_NEXTFLOW_BIN = str(_cand_nf)
    except Exception:
        BACTOPIA_NEXTFLOW_BIN = None


def get_nextflow_bin() -> str:
    """
    Get the path to the Nextflow executable.

    Priority order:
      1) st.session_state['nextflow_bin']
      2) $NEXTFLOW_BIN
      3) BACTOPIA_ENV_PREFIX/bin/nextflow
      4) 'nextflow' in the system PATH

    Returns:
        str: Path to Nextflow.
    """
    v = (st.session_state.get("nextflow_bin") or "").strip()
    if v:
        return v
    v = (os.environ.get("NEXTFLOW_BIN") or "").strip()
    if v:
        return v
    if BACTOPIA_NEXTFLOW_BIN:
        return BACTOPIA_NEXTFLOW_BIN
    return "nextflow"

# ============================= Helps (popovers) =============================

def help_popover(label: str, text: str):
    """
    Show a help text inside a popover.

    Args:
        label (str): Label for the popover button.
        text (str): Markdown text content.
    """
    with st.popover(label):
        st.markdown(text)

def help_header(title_md: str, help_key: str, ratio=(4, 1)):
    """
    Render a header row with a help button.

    Args:
        title_md (str): Markdown title string.
        help_key (str): Key to look up help text in the HELP dictionary.
        ratio (tuple): Ratio of column widths for title vs help button.
    """
    c1, c2 = st.columns(ratio)
    with c1:
        st.markdown(title_md)
    with c2:
        help_popover("‚ùì Help", HELP[help_key])


HELP = {}

HELP["amostras"] = """
### Sample selection

- The list is inferred from the **folders** inside `--bactopia` (one folder per sample).
- The UI automatically generates an `--include` file with the selected samples.

### `--include` / `--exclude` (in the Pangenome section)

- These fields accept a **TXT file path**, with **one sample name per line** (e.g. `sampleA`).
- Names must match **exactly** the sample folders inside `--bactopia`.
- `--include` in the Pangenome section **overrides** the automatic include file generated by the UI.
- `--exclude` removes samples from the current set.
- Avoid commas or headers; empty lines are ignored. Prefer **absolute** paths.
"""

HELP["gerais"] = """
**General Nextflow/Bactopia parameters**

- **`-profile`**  
  Execution environment. Examples:
  - `docker` (Docker containers),
  - `singularity` (Apptainer),
  - `standard` (no containers).

- **`--max_cpus`**  
  Global thread limit for the Nextflow scheduler (not per task).

- **`--max_memory`**  
  Global memory limit, e.g. `64.GB`. Tasks that require more memory will wait in a queue.

- **`-resume`**  
  Reuses already completed steps via Nextflow's cache. Recommended to keep it **enabled**.

- **`Extras`**  
  Free-form field for additional flags:
  - extra Nextflow parameters (e.g. `-with-report report.html`)
  - extra Bactopia Tools parameters.
"""

HELP["pangenome"] = """
**`pangenome` workflow ‚Äî overview**

- Input: samples already processed by Bactopia (`--bactopia`),
  using the GFF3 annotation files.
- You may include **RefSeq references** via `--species` or `--accessions`.
- Available engines:
  - **Panaroo** (default; graph-based, robust to fragmented genomes).
  - **PIRATE** (clustering across multiple identity thresholds).
  - **Roary** (classic/faster).

**Typical output**

- Gene presence/absence matrix.
- Core genome + alignment.
- Tree built with **IQ-TREE** (optionally masking recombination).
- Distances with `snp-dists` and gene‚Äìphenotype association with **Scoary**.

**Good practices**

- Use `--species` *or* `--accessions` to anchor on canonical references.
- Enable `--skip_recombination` only if recombination is not relevant.
- For stronger branch support: configure `--bb` (bootstrap) and/or `--alrt`.
"""

HELP["iqtree"] = """
**IQ-TREE (phylogeny)**

- **`--iqtree_model`**  
  Substitution model (e.g. `GTR+G`).  
  If left blank, IQ-TREE chooses automatically (*ModelFinder*).

- **`--bb`**  
  *Ultrafast bootstrap* (e.g. `1000`).  
  Higher values give more stable support but increase runtime.

- **`--alrt`**  
  *Approximate Likelihood Ratio Test* (e.g. `1000`).  
  Can be used together with or instead of bootstrap.

- **`--asr`**  
  Enables ancestral state reconstruction.

- **`--iqtree_opts`**  
  Free-form field for additional IQ-TREE options (e.g. `-nt AUTO --safe`).
"""

HELP["panaroo"] = """
**Panaroo (engine)**

- **`--panaroo_mode`**: execution mode (`strict`, `sensitive`, ...).
- **`--panaroo_alignment`**: which genes to align (e.g. `core`, `all`).
- **`--panaroo_aligner`**: aligner (e.g. `mafft`).
- **`--panaroo_core_threshold`**: minimum fraction for a gene to be considered *core* (e.g. `0.95`).
- **`--panaroo_threshold`**: minimum identity for orthologs.
- **`--panaroo_family_threshold`**: minimum identity for families.
- **`--len_dif_percent`**: length difference tolerance.
- **`--merge_paralogs`**: attempts to merge paralogs.
- **`panaroo_opts`**: extra options passed directly to Panaroo.
"""

HELP["pirate"] = """
**PIRATE (engine)**

- **`--steps`**: list of identity thresholds for clustering (e.g. `50,60,70,80,90,95,98`).
- **`--features`**: feature types (e.g. `CDS`).
- **`--para_off`**: disables paralog identification.
- **`--z`**: keeps intermediate files.
- **`pan_opt`**: raw options forwarded to PIRATE.
"""

HELP["roary"] = """
**Roary (engine)**

- **`--i`**: minimum BLASTp identity (%), e.g. `95`.
- **`--cd`**: minimum percentage for core definition (e.g. `99`).
- **`--g`**: maximum number of gene families (e.g. `50000`).
- **`--iv`**: MCL inflation parameter (controls clustering granularity).
- **`--s`**: do not split paralogs.
- **`--ap`**: allow paralogs in the core.
- **`--use_prank`**: use PRANK for gene alignments.
"""

HELP["prokka"] = """
**Prokka (reference re-annotation)**

- **`--proteins`**: FASTA with reference proteins to guide annotations.
- **`prokka_opts`**: free-form Prokka options (e.g. `--kingdom Bacteria --genus Escherichia`).
"""

HELP["scoary_snpdists"] = """
**Scoary & SNP-dists**

- **Scoary**
  - **`--traits`**: CSV/TSV with phenotypes (sample names must match the pangenome).
  - **`--p_value_cutoff`**, `--correction`, `--start_col`:
    control significance and how phenotype columns are parsed.
  - **`--permute`**: enables random phenotype permutations (slower; useful for empirical significance).

- **SNP-dists**
  - Computes distance matrix from the alignment.
  - **`--csv`**: exports CSV in addition to TSV.
"""

HELP["amrfinderplus"] = """
**AMRFinderPlus**

- Detects **resistance** and **virulence** genes/mutations.
- Main flags:
  - **`--plus`**: includes additional targets.
  - **`--mutation_all`**: reports relevant SNPs.
  - **`--ident_min`** / **`--coverage_min`**:
    identity/coverage thresholds.
  - **`--organism`**:
    restricts searches to a specific taxon (improves specificity).
- The ‚ÄúAMRFinderPlus extras‚Äù field accepts additional raw options.
"""

HELP["rgi"] = """
**RGI (CARD)**

- Predicts **AMR** using the CARD database.
- Common options:
  - **`--use_diamond`**: speeds up search using DIAMOND (recommended).
  - **`--include_loose`**: includes *loose hits*.
  - **`--exclude_nudge`**: removes *nudged hits*.
  - **`--frequency`**, `--category`, `--cluster`, `--display`:
    further control filters and output format.
"""

HELP["mlst"] = """
**MLST**

- **`--scheme`**: scheme name (e.g. `ecoli`, `staphylococcus_aureus`).
- **`--minid`**, `--mincov`, `--minscore`:
  minimum identity, coverage and score to accept a ST.
- **`--nopath`**: disables pathway resolution in specific schemes.
"""

HELP["mashtree"] = """
**Mashtree**

- Builds fast trees using Mash *sketches*.
- Main parameters:
  - **`--kmerlength`**, `--sketchsize`:
    control resolution and computational cost.
  - **`--trunclength`**, `--genomesize`:
    control truncation and expected genome size.
  - **`--mindepth`**, `--sortorder`:
    fine tuning of the build/order.
  - **`--save_sketches`**: saves sketches for reuse.
"""

HELP["plasmidfinder"] = """
**PlasmidFinder**

- Identifies replicons/plasmids in bacterial genomes.
- Main parameters:
  - **`--pf_mincov`**:
    minimum coverage (0‚Äì1; e.g. `0.6` = 60%) to consider a hit.
  - **`--pf_threshold`**:
    minimum identity (0‚Äì1; e.g. `0.9` = 90%) to consider a hit.
- The ‚ÄúPlasmidFinder extras‚Äù field accepts additional options supported by Bactopia Tools.
"""

# ============================= File explorer (pop-up) =============================

def _safe_id(s: str) -> str:
    """Generate a short hash ID for a string."""
    return hashlib.md5(s.encode("utf-8")).hexdigest()[:10]


def _list_dir(cur: pathlib.Path) -> tuple[list[pathlib.Path], list[pathlib.Path]]:
    """
    List subdirectories and files in the given directory.

    Args:
        cur (pathlib.Path): The directory to list.

    Returns:
        tuple: (sorted_dirs, sorted_files)
    """
    try:
        entries = list(cur.iterdir())
    except Exception:
        entries = []
    dirs = [p for p in entries if p.is_dir()]
    files = [p for p in entries if p.is_file()]
    dirs.sort(key=lambda p: p.name.lower())
    files.sort(key=lambda p: p.name.lower())
    return dirs, files


def _fs_browser_core(label: str, key: str, mode: str = "file",
                     start: str | None = None, patterns: list[str] | None = None):
    """
    Render the core UI for the file/directory browser.

    Args:
        label (str): Label for the browser.
        key (str): Unique session state key.
        mode (str): "file" or "dir".
        start (str | None): Starting directory.
        patterns (list[str] | None): File patterns to match (e.g. ["*.txt"]).
    """
    base_start = start or st.session_state.get(key) or os.getcwd()
    cur_key = f"__picker_cur__{key}"
    try:
        cur = pathlib.Path(st.session_state.get(cur_key, base_start)).expanduser().resolve()
    except Exception:
        cur = pathlib.Path(base_start).expanduser().resolve()

    def set_cur(p: pathlib.Path):
        st.session_state[cur_key] = str(p.expanduser().resolve())

    hostfs_root = os.getenv("HOSTFS_ROOT", "/hostfs")

    c_up, c_home, c_host, c_path, c_pick = st.columns([0.9, 0.9, 0.9, 6, 2])

    with c_up:
        if st.button("‚¨ÜÔ∏è Up", key=f"{key}_up"):
            parent = cur.parent if cur.parent != cur else cur
            set_cur(parent)
            _st_rerun()

    with c_home:
        home_base = pathlib.Path(start or pathlib.Path.home())
        if st.button("üè† Base", key=f"{key}_home"):
            set_cur(home_base)
            _st_rerun()

    with c_host:
        if os.path.exists(hostfs_root):
            if st.button("üñ• Host", key=f"{key}_host"):
                set_cur(pathlib.Path(hostfs_root))
                _st_rerun()

    with c_path:
        st.caption(str(cur))

    with c_pick:
        if mode == "dir":
            if st.button("Choose", key=f"{key}_choose_dir"):
                st.session_state[key] = str(cur)

    dirs, files = _list_dir(cur)
    st.markdown("**Folders**")
    dcols = st.columns(2)
    for i, d in enumerate(dirs):
        did = _safe_id(str(d))
        if dcols[i % 2].button("üìÅ " + d.name, key=f"{key}_d_{did}"):
            set_cur(d)
            _st_rerun()

    if mode == "file":
        if patterns:
            files = [f for f in files if any(fnmatch.fnmatch(f.name, pat) for pat in patterns)]
        st.markdown("**Files**")
        for f in files:
            fid = _safe_id(str(f))
            if st.button("üìÑ " + f.name, key=f"{key}_f_{fid}"):
                st.session_state[key] = str(f.resolve())
                st.session_state[f"__open_{key}"] = False
                _st_rerun()


def path_picker(label: str, key: str, mode: str = "dir",
                start: str | None = None, patterns: list[str] | None = None, help: str | None = None):
    """
    Render a path picker with a text input and a 'Browse' button.

    Args:
        label (str): Label for the input.
        key (str): Unique session state key.
        mode (str): "file" or "dir".
        start (str | None): Initial path.
        patterns (list[str] | None): File glob patterns (if mode="file").
        help (str | None): Tooltip help text.

    Returns:
        str: The selected path.
    """
    open_key = f"__open_{key}"
    cur_key = f"__picker_cur__{key}"

    if open_key not in st.session_state:
        st.session_state[open_key] = False

    col1, col2 = st.columns([7, 2])
    with col1:
        val = st.text_input(label, value=st.session_state.get(key, start or ""), key=key, help=help)
        try:
            if val:
                val_abs = str(pathlib.Path(val).expanduser().resolve())
                if val_abs != val:
                    st.session_state[key] = val_abs
        except Exception:
            pass
    with col2:
        if st.button("Browse‚Ä¶", key=f"open_{key}"):
            st.session_state[open_key] = True
            try:
                hint = pathlib.Path(st.session_state.get(key) or start or os.getcwd())
                base = hint if hint.is_dir() else hint.parent
                st.session_state[cur_key] = str(base.expanduser().resolve())
            except Exception:
                st.session_state[cur_key] = str(
                    pathlib.Path(start or os.getcwd()).expanduser().resolve()
                )

    # Pop-up via st.dialog (if available)
    if st.session_state.get(open_key, False) and hasattr(st, "dialog"):
        @st.dialog(label, width="large")
        def _dlg():
            _fs_browser_core(label, key, mode=mode, start=start, patterns=patterns)
            c_ok, c_cancel = st.columns(2)
            with c_ok:
                if st.button("‚úÖ Use this path", key=f"use_{key}"):
                    if mode == "dir":
                        cur = pathlib.Path(st.session_state.get(cur_key, start or os.getcwd()))
                        st.session_state[key] = str(cur.expanduser().resolve())
                    st.session_state[open_key] = False
                    _st_rerun()
            with c_cancel:
                if st.button("Cancel", key=f"cancel_{key}"):
                    st.session_state[open_key] = False
                    _st_rerun()
        _dlg()

    # Inline fallback if st.dialog does not exist (older Streamlit)
    elif st.session_state.get(open_key, False):
        st.info(f"{label} (inline mode ‚Äî fallback)")
        _fs_browser_core(label, key, mode=mode, start=start, patterns=patterns)
        c_ok, c_cancel = st.columns(2)
        with c_ok:
            if st.button("‚úÖ Use this path", key=f"use_inline_{key}"):
                if mode == "dir":
                    cur = pathlib.Path(st.session_state.get(cur_key, start or os.getcwd()))
                    st.session_state[key] = str(cur.expanduser().resolve())
                st.session_state[open_key] = False
                _st_rerun()
        with c_cancel:
            if st.button("Cancel", key=f"cancel_inline_{key}"):
                st.session_state[open_key] = False
                _st_rerun()

    return st.session_state.get(key) or ""

# ============================= Utils =============================

def ensure_state_dir():
    """Ensure the application state directory exists."""
    APP_STATE_DIR.mkdir(parents=True, exist_ok=True)

def which(cmd: str):
    """Locate a command in PATH."""
    from shutil import which as _which
    return _which(cmd)

def nextflow_available():
    """
    Check if a usable Nextflow binary is found.

    Returns:
        bool: True if Nextflow is available.
    """
    if (st.session_state.get("nextflow_bin") or "").strip():
        return True
    if (os.environ.get("NEXTFLOW_BIN") or "").strip():
        return True
    if BACTOPIA_NEXTFLOW_BIN:
        return True
    return which("nextflow") is not None

def have_tool(name: str) -> bool:
    """Check if a specific tool is in PATH."""
    return which(name) is not None

ANSI_ESCAPE = re.compile(r"\x1B\[[0-?]*[ -/]*[@-~]")

def _strip_ansi(s: str) -> str:
    """Strip ANSI codes from a string."""
    return ANSI_ESCAPE.sub("", s)

def _normalize_linebreaks(chunk: str) -> list[str]:
    """
    Normalize Nextflow log output for display.

    Args:
        chunk (str): Raw output chunk.

    Returns:
        list[str]: Cleaned lines.
    """
    if not chunk:
        return []
    chunk = _strip_ansi(chunk).replace("\r", "\n")
    chunk = re.sub(r"\s+-\s+\[", "\n[", chunk)
    chunk = re.sub(r"(?<!^)\s+(?=executor\s*>)", "\n", chunk, flags=re.IGNORECASE)
    chunk = re.sub(r"‚úî\s+(?=\[)", "‚úî\n", chunk)
    return [p.rstrip() for p in chunk.split("\n") if p.strip() != ""]

async def _async_read_stream(stream, log_q: Queue, stop_event: threading.Event):
    """Async reader for subprocess stdout/stderr."""
    while True:
        line = await stream.readline()
        if not line:
            break
        s = line.decode(errors="replace")
        for sub in _normalize_linebreaks(s):
            log_q.put(sub)
        if stop_event.is_set():
            break

async def _async_exec(full_cmd: str, log_q: Queue, status_q: Queue, stop_event: threading.Event):
    """Async execution wrapper for shell commands."""
    try:
        proc = await asyncio.create_subprocess_exec(
            "bash", "-lc", full_cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
    except Exception as e:
        status_q.put(("error", f"Failed to start process: {e}"))
        return
    t_out = asyncio.create_task(_async_read_stream(proc.stdout, log_q, stop_event))
    t_err = asyncio.create_task(_async_read_stream(proc.stderr, log_q, stop_event))
    while True:
        if stop_event.is_set():
            try:
                proc.terminate()
                try:
                    await asyncio.wait_for(proc.wait(), timeout=5.0)
                except asyncio.TimeoutError:
                    proc.kill()
            except ProcessLookupError:
                pass
            break
        if proc.returncode is not None:
            break
        await asyncio.sleep(0.1)
    try:
        await asyncio.gather(t_out, t_err)
    except Exception:
        pass
    rc = await proc.wait()
    status_q.put(("rc", rc))

def _thread_entry(full_cmd: str, log_q: Queue, status_q: Queue, stop_event: threading.Event):
    """Thread entry point for async execution loop."""
    loop = asyncio.new_event_loop()
    try:
        asyncio.set_event_loop(loop)
        loop.run_until_complete(_async_exec(full_cmd, log_q, status_q, stop_event))
    finally:
        loop.close()

def start_async_runner_ns(full_cmd: str, ns: str):
    """
    Start an asynchronous runner in a separate thread.

    Args:
        full_cmd (str): The command to run.
        ns (str): Namespace for session state keys (e.g., 'tools').
    """
    log_q = Queue()
    status_q = Queue()
    stop_event = threading.Event()
    th = threading.Thread(
        target=_thread_entry,
        args=(full_cmd, log_q, status_q, stop_event),
        daemon=True,
    )
    th.start()
    st.session_state[f"{ns}_running"] = True
    st.session_state[f"{ns}_log_q"] = log_q
    st.session_state[f"{ns}_status_q"] = status_q
    st.session_state[f"{ns}_stop_event"] = stop_event
    st.session_state[f"{ns}_thread"] = th
    st.session_state[f"{ns}_live_log"] = []

def request_stop_ns(ns: str):
    """Signal the async runner to stop."""
    ev = st.session_state.get(f"{ns}_stop_event")
    if ev and not ev.is_set():
        ev.set()

def drain_log_queue_ns(ns: str, tail_limit: int = 200, max_pull: int = 500):
    """
    Move messages from log queue into `st.session_state`.

    Args:
        ns (str): Namespace string.
        tail_limit (int): Max lines to keep.
        max_pull (int): Max lines to process per call.
    """
    q: Queue = st.session_state.get(f"{ns}_log_q")
    if not q:
        return
    buf = st.session_state.get(f"{ns}_live_log", [])
    pulled = 0
    while pulled < max_pull:
        try:
            line = q.get_nowait()
        except Empty:
            break
        buf.append(line)
        pulled += 1
    if len(buf) > tail_limit:
        buf[:] = buf[-tail_limit:]
    st.session_state[f"{ns}_live_log"] = buf

def render_log_box_ns(ns: str, height: int = 520):
    """
    Render a custom HTML ‚Äúterminal‚Äù log box.

    Args:
        ns (str): Namespace string.
        height (int): Height in pixels.
    """
    lines = st.session_state.get(f"{ns}_live_log", [])
    content = html.escape("\n".join(lines)) if lines else ""
    components.html(
        f"""
    <div id="logbox_{ns}" style=
        "
        width:100%; height:{height-40}px; margin:0 auto; padding:12px;
        overflow-y:auto; overflow-x:auto; background:#0b0b0b; color:#e6e6e6;
        border-radius:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace;
        font-size:13px; line-height:1.35;">
      <pre style="margin:0; white-space: pre;">{content or "&nbsp;"}</pre>
    </div>
    <script>const el=document.getElementById("logbox_{ns}"); if(el){{el.scrollTop=el.scrollHeight;}}</script>
    """,
        height=height,
        scrolling=False,
    )

def check_status_and_finalize_ns(ns: str, status_box):
    """
    Check if the async runner has finished and update the visual status.

    Args:
        ns (str): Namespace string.
        status_box: Streamlit status element.

    Returns:
        bool: True if finished, False otherwise.
    """
    sq: Queue = st.session_state.get(f"{ns}_status_q")
    if not sq:
        return False
    finalized = False
    msg = None
    rc = None
    try:
        while True:
            kind, payload = sq.get_nowait()
            if kind == "error":
                msg = payload
                finalized = True
                rc = -1
            elif kind == "rc":
                rc = int(payload)
                finalized = True
    except Empty:
        pass
    if finalized:
        st.session_state[f"{ns}_running"] = False
        st.session_state[f"{ns}_thread"] = None
        st.session_state[f"{ns}_stop_event"] = None
        if rc == 0:
            status_box.success("Finished successfully.")
        else:
            status_box.error(msg or f"Execution finished with code {rc}. See the log below.")
    return finalized

# ============================= Page =============================

ICON_PATH = PROJECT_ROOT / "static" / "bear-hub-icon.png"
ICON_PATH_BACTOPIA_TOOLS = PROJECT_ROOT / "static" / "BEAR-BACTOPIA-TOOLS.png"

if ICON_PATH_BACTOPIA_TOOLS.is_file():
    st.image(str(ICON_PATH_BACTOPIA_TOOLS), width=500)
else:
    st.title("üß∞ Bactopia ‚Äî Official Tools")

# ------------------------- Folder/sample selection -------------------------
st.subheader("Folder and sample selection")
help_popover("‚ùì Help", HELP["amostras"])

def discover_samples_from_outdir(outdir: str) -> List[str]:
    """
    Discover samples in a Bactopia output directory.

    Args:
        outdir (str): Path to the Bactopia output directory.

    Returns:
        List[str]: A list of detected sample names.
    """
    p = pathlib.Path(outdir)
    if not p.exists() or not p.is_dir():
        return []
    samples_strict: List[str] = []
    candidates: List[str] = []

    for child in sorted(p.iterdir(), key=lambda x: x.name):
        if not child.is_dir():
            continue
        # Ignore administrative directories
        if child.name.startswith("bactopia-") or child.name in {"bactopia-runs", "work"}:
            continue
        candidates.append(child.name)
        # Classic Bactopia structure
        if (child / "main").exists() or (child / "tools").exists():
            samples_strict.append(child.name)

    if samples_strict:
        return samples_strict
    return candidates

def _guess_bt_root_default() -> str:
    """
    Attempt to guess the Bactopia results folder location.

    Checks standard locations like project root, BEAR_DATA, etc.

    Returns:
        str: The best guess path.
    """
    candidates: list[pathlib.Path] = []

    global_outdir = st.session_state.get("outdir")
    if global_outdir:
        base = pathlib.Path(global_outdir).expanduser()
        candidates.append(base)
        candidates.append(base / "bactopia_out")

    # Local projects
    candidates.append(PROJECT_ROOT / "bactopia_out")
    candidates.append(APP_ROOT / "bactopia_out")

    # Default fallback
    candidates.append(pathlib.Path.home() / "BEAR_DATA" / "bactopia_out")

    for cand in candidates:
        try:
            cand = cand.expanduser().resolve()
            if cand.exists() and cand.is_dir():
                if discover_samples_from_outdir(str(cand)):
                    return str(cand)
        except Exception:
            pass

    # If nothing worked, use the last fallback anyway
    return str((pathlib.Path.home() / "BEAR_DATA" / "bactopia_out").expanduser().resolve())


bt_root_default = _guess_bt_root_default()

# bt_outdir is initially defined only here, so we don't fight with the widget
if "bt_outdir" not in st.session_state or not st.session_state["bt_outdir"]:
    st.session_state["bt_outdir"] = bt_root_default

bt_outdir = path_picker(
    "Bactopia results folder",
    key="bt_outdir",
    mode="dir",
    start=bt_root_default,
    help="Folder that contains Bactopia sample folders (one folder per sample).",
)
# if the user clears the field, fall back to the computed default
bt_outdir = bt_outdir or bt_root_default
bt_outdir = str(pathlib.Path(bt_outdir).expanduser().resolve())
st.caption(f"Current directory: `{bt_outdir}`")

# Detect folder change to force selection of all samples
prev_bt_outdir = st.session_state.get("_prev_bt_outdir")
folder_changed = prev_bt_outdir is not None and prev_bt_outdir != bt_outdir
st.session_state["_prev_bt_outdir"] = bt_outdir

# Discover samples inside the current bt_outdir
samples = discover_samples_from_outdir(bt_outdir) if bt_outdir else []

if samples:
    prev_sel = st.session_state.get("bt_selected_samples", [])
    if not isinstance(prev_sel, list):
        prev_sel = []

    if folder_changed:
        # If the folder changed, select ALL samples automatically
        default_sel = samples.copy()
    else:
        # If the folder is the same, keep intersection with current options
        default_sel = [s for s in prev_sel if s in samples]
        if not default_sel:
            default_sel = samples.copy()

    st.session_state["bt_selected_samples"] = default_sel

    sel = st.multiselect(
        "Samples",
        options=samples,
        default=default_sel,
        key="bt_selected_samples",
    )
else:
    sel = []
    if bt_outdir:
        st.warning("No samples found in this folder.")

st.divider()
st.subheader("Bactopia tools")

r1 = st.columns(5)
with r1[0]:
    st.checkbox("amrfinderplus", value=st.session_state.get("bt_run_amrfinderplus", False), key="bt_run_amrfinderplus")
with r1[1]:
    st.checkbox("rgi", value=st.session_state.get("bt_run_rgi", False), key="bt_run_rgi")
with r1[2]:
    st.checkbox("abricate", value=st.session_state.get("bt_run_abricate", False), key="bt_run_abricate")
with r1[3]:
    st.checkbox("mobsuite", value=st.session_state.get("bt_run_mobsuite", False), key="bt_run_mobsuite")
with r1[4]:
    st.checkbox("mlst", value=st.session_state.get("bt_run_mlst", False), key="bt_run_mlst")

r2 = st.columns(5)
with r2[0]:
    st.checkbox("pangenome", value=st.session_state.get("bt_run_pangenome", False), key="bt_run_pangenome")
with r2[1]:
    st.checkbox("mashtree", value=st.session_state.get("bt_run_mashtree", False), key="bt_run_mashtree")
with r2[2]:
    st.checkbox("plasmidfinder", value=st.session_state.get("bt_run_plasmidfinder", False), key="bt_run_plasmidfinder")

# ------------------------- General parameters -------------------------
with st.expander("General parameters", expanded=True):
    bt_profile = st.selectbox("Profile (-profile)", ["docker", "singularity", "standard"], index=0, key="bt_profile")
    bt_threads = st.slider("--max_cpus", 0, min(os.cpu_count() or 64, 128), 0, 1, key="bt_threads")
    bt_memory_gb = st.slider("--max_memory (GB)", 0, 256, 0, 1, key="bt_memory_gb")
    bt_resume = st.checkbox("-resume", value=True, key="bt_resume")
    bt_extra = st.text_input(
        "Extras (raw line, optional)",
        key="bt_extra",
        value=st.session_state.get("bt_extra", ""),
        help="Additional flags for Nextflow/Bactopia (e.g. -with-report, global parameters, etc.).",
    )
    help_popover("‚ùì Help (general parameters)", HELP["gerais"])

# ------------------------- Tool-specific options -------------------------

# ABRicate
if st.session_state.get("bt_run_abricate"):
    st.markdown("**ABRicate ‚Äî options**")
    st.text_input(
        "--abricate_db (e.g. ncbi,plasmidfinder)",
        key="bt_abricate_db",
        value=st.session_state.get("bt_abricate_db", ""),
    )

# --- AMRFinderPlus ---
if st.session_state.get("bt_run_amrfinderplus"):
    help_header("**AMRFinderPlus ‚Äî options**", "amrfinderplus")
    c1, c2, c3 = st.columns(3)
    with c1:
        st.checkbox("--plus", value=st.session_state.get("bt_amrfinderplus_plus", True), key="bt_amrfinderplus_plus")
        st.checkbox(
            "--mutation_all",
            value=st.session_state.get("bt_amrfinderplus_mutation_all", False),
            key="bt_amrfinderplus_mutation_all",
        )
    with c2:
        st.number_input(
            "--ident_min",
            0.0,
            100.0,
            value=st.session_state.get("bt_amrfinderplus_ident_min", 90.0),
            step=0.5,
            key="bt_amrfinderplus_ident_min",
        )
        st.number_input(
            "--coverage_min",
            0.0,
            100.0,
            value=st.session_state.get("bt_amrfinderplus_coverage_min", 50.0),
            step=0.5,
            key="bt_amrfinderplus_coverage_min",
        )
    with c3:
        st.text_input(
            "--organism (e.g. Enterobacteriaceae)",
            value=st.session_state.get("bt_amrfinderplus_organism", ""),
            key="bt_amrfinderplus_organism",
        )
    c4, c5, c6 = st.columns(3)
    with c4:
        st.checkbox(
            "--report_common",
            value=st.session_state.get("bt_amrfinderplus_report_common", False),
            key="bt_amrfinderplus_report_common",
        )
    with c5:
        st.checkbox(
            "--report_all_equal_best",
            value=st.session_state.get("bt_amrfinderplus_report_all_equal_best", False),
            key="bt_amrfinderplus_report_all_equal_best",
        )
    with c6:
        st.checkbox(
            "--allow_overlap",
            value=st.session_state.get("bt_amrfinderplus_allow_overlap", False),
            key="bt_amrfinderplus_allow_overlap",
        )
    st.checkbox(
        "--exclude_quick_need_prediction",
        value=st.session_state.get("bt_amrfinderplus_exclude_quick_need_prediction", False),
        key="bt_amrfinderplus_exclude_quick_need_prediction",
    )
    st.text_input(
        "AMRFinderPlus extras (raw line/append)",
        value=st.session_state.get("bt_amrfinderplus_extra", ""),
        key="bt_amrfinderplus_extra",
    )

# --- RGI ---
if st.session_state.get("bt_run_rgi"):
    help_header("**RGI (CARD) ‚Äî options**", "rgi")
    c1, c2, c3, c4 = st.columns(4)
    with c1:
        st.checkbox("--use_diamond", value=st.session_state.get("bt_rgi_use_diamond", True), key="bt_rgi_use_diamond")
    with c2:
        st.checkbox(
            "--include_loose",
            value=st.session_state.get("bt_rgi_include_loose", False),
            key="bt_rgi_include_loose",
        )
    with c3:
        st.checkbox(
            "--exclude_nudge",
            value=st.session_state.get("bt_rgi_exclude_nudge", False),
            key="bt_rgi_exclude_nudge",
        )
    with c4:
        st.text_input(
            "--frequency (e.g. 'perfect,strict')",
            value=st.session_state.get("bt_rgi_frequency", ""),
            key="bt_rgi_frequency",
        )
    c5, c6, c7 = st.columns(3)
    with c5:
        st.text_input("--category", value=st.session_state.get("bt_rgi_category", ""), key="bt_rgi_category")
    with c6:
        st.text_input("--cluster", value=st.session_state.get("bt_rgi_cluster", ""), key="bt_rgi_cluster")
    with c7:
        st.text_input("--display", value=st.session_state.get("bt_rgi_display", ""), key="bt_rgi_display")
    st.text_input(
        "RGI extras (raw line/append)",
        value=st.session_state.get("bt_rgi_extra", ""),
        key="bt_rgi_extra",
    )

# --- MLST ---
if st.session_state.get("bt_run_mlst"):
    help_header("**MLST ‚Äî options**", "mlst")
    c1, c2, c3, c4, c5 = st.columns(5)
    with c1:
        st.text_input("--scheme", value=st.session_state.get("bt_mlst_scheme", ""), key="bt_mlst_scheme")
    with c2:
        st.number_input(
            "--minid",
            0.0,
            100.0,
            value=st.session_state.get("bt_mlst_minid", 95.0),
            step=0.5,
            key="bt_mlst_minid",
        )
    with c3:
        st.number_input(
            "--mincov",
            0.0,
            100.0,
            value=st.session_state.get("bt_mlst_mincov", 50.0),
            step=0.5,
            key="bt_mlst_mincov",
        )
    with c4:
        st.number_input(
            "--minscore",
            0.0,
            100.0,
            value=st.session_state.get("bt_mlst_minscore", 0.0),
            step=0.5,
            key="bt_mlst_minscore",
        )
    with c5:
        st.checkbox("--nopath", value=st.session_state.get("bt_mlst_nopath", False), key="bt_mlst_nopath")

# --- PlasmidFinder ---
if st.session_state.get("bt_run_plasmidfinder"):
    help_header("**PlasmidFinder ‚Äî options**", "plasmidfinder")
    c1, c2 = st.columns(2)
    with c1:
        st.number_input(
            "--pf_mincov (0‚Äì1, e.g. 0.6)",
            0.0,
            1.0,
            value=st.session_state.get("bt_pf_mincov", 0.6),
            step=0.05,
            key="bt_pf_mincov",
        )
    with c2:
        st.number_input(
            "--pf_threshold (0‚Äì1, e.g. 0.9)",
            0.0,
            1.0,
            value=st.session_state.get("bt_pf_threshold", 0.9),
            step=0.05,
            key="bt_pf_threshold",
        )
    st.text_input(
        "PlasmidFinder extras (raw line/append)",
        value=st.session_state.get("bt_plasmidfinder_extra", ""),
        key="bt_plasmidfinder_extra",
    )

# --- Pangenome subset ---
if st.session_state.get("bt_run_pangenome"):
    help_header("**Pangenome ‚Äî main options**", "pangenome")
    st.caption(
        "Includes engine (Panaroo/PIRATE/Roary) + IQ-TREE + Prokka + Scoary + SNP-dists. "
        "Use global 'Extras' for additional Nextflow flags."
    )

    # Engine
    c1, c2 = st.columns([1, 3])
    with c1:
        st.radio(
            "Engine",
            options=["Panaroo", "PIRATE", "Roary"],
            index=["Panaroo", "PIRATE", "Roary"].index(
                st.session_state.get("bt_pangenome_engine", "Panaroo")
            ),
            key="bt_pangenome_engine",
        )
    with c2:
        help_popover("‚ÑπÔ∏è Engine (Panaroo/PIRATE/Roary)", HELP["pangenome"])

    # Additional sample selection (pangenome only)
    st.markdown("_Extra sample selection (pangenome only; optional)_")
    cc1, cc2 = st.columns(2)
    with cc1:
        st.text_input(
            "--include file (one name per line) [‚ö†Ô∏è overrides automatic include]",
            value=st.session_state.get("bt_pangenome_include", ""),
            key="bt_pangenome_include",
        )
    with cc2:
        st.text_input(
            "--exclude file (one name per line)",
            value=st.session_state.get("bt_pangenome_exclude", ""),
            key="bt_pangenome_exclude",
        )

    # Downloaded references (RefSeq)
    st.markdown("_Reference genomes (RefSeq; optional)_")
    c3, c4 = st.columns(2)
    with c3:
        st.text_input(
            "--species (e.g. Escherichia coli)",
            value=st.session_state.get("bt_pangenome_species", ""),
            key="bt_pangenome_species",
        )
    with c4:
        st.text_input(
            "--accessions (file with 1 accession per line OR CSV)",
            value=st.session_state.get("bt_pangenome_accessions", ""),
            key="bt_pangenome_accessions",
        )

    # Recombination
    st.checkbox(
        "--skip_recombination (skip ClonalFrameML)",
        value=st.session_state.get("bt_pangenome_skip_recombination", False),
        key="bt_pangenome_skip_recombination",
    )

    # IQ-TREE
    help_header("_IQ-TREE_", "iqtree", ratio=(3, 1))
    q1, q2, q3, q4 = st.columns(4)
    with q1:
        st.text_input(
            "--iqtree_model",
            value=st.session_state.get("bt_iqtree_model", ""),
            key="bt_iqtree_model",
        )
    with q2:
        st.number_input(
            "--bb",
            0,
            5000,
            value=st.session_state.get("bt_iqtree_bb", 0),
            step=100,
            key="bt_iqtree_bb",
        )
    with q3:
        st.number_input(
            "--alrt",
            0,
            5000,
            value=st.session_state.get("bt_iqtree_alrt", 0),
            step=100,
            key="bt_iqtree_alrt",
        )
    with q4:
        st.checkbox("--asr", value=st.session_state.get("bt_iqtree_asr", False), key="bt_iqtree_asr")
    st.text_input(
        "iqtree_opts (append)",
        value=st.session_state.get("bt_iqtree_opts", ""),
        key="bt_iqtree_opts",
    )

    # Panaroo (visible if engine == Panaroo)
    if st.session_state.get("bt_pangenome_engine", "Panaroo") == "Panaroo":
        help_header("_Panaroo_", "panaroo", ratio=(3, 1))
        p1, p2, p3, p4 = st.columns(4)
        with p1:
            st.text_input(
                "--panaroo_mode",
                value=st.session_state.get("bt_panaroo_mode", ""),
                key="bt_panaroo_mode",
            )
        with p2:
            st.text_input(
                "--panaroo_alignment",
                value=st.session_state.get("bt_panaroo_alignment", ""),
                key="bt_panaroo_alignment",
            )
        with p3:
            st.text_input(
                "--panaroo_aligner",
                value=st.session_state.get("bt_panaroo_aligner", ""),
                key="bt_panaroo_aligner",
            )
        with p4:
            st.checkbox(
                "--merge_paralogs",
                value=st.session_state.get("bt_panaroo_merge_paralogs", False),
                key="bt_panaroo_merge_paralogs",
            )
        p5, p6, p7, p8 = st.columns(4)
        with p5:
            st.text_input(
                "--panaroo_core_threshold",
                value=st.session_state.get("bt_panaroo_core_threshold", ""),
                key="bt_panaroo_core_threshold",
            )
        with p6:
            st.text_input(
                "--panaroo_threshold",
                value=st.session_state.get("bt_panaroo_threshold", ""),
                key="bt_panaroo_threshold",
            )
        with p7:
            st.text_input(
                "--panaroo_family_threshold",
                value=st.session_state.get("bt_panaroo_family_threshold", ""),
                key="bt_panaroo_family_threshold",
            )
        with p8:
            st.text_input(
                "--len_dif_percent",
                value=st.session_state.get("bt_panaroo_len_dif_percent", ""),
                key="bt_panaroo_len_dif_percent",
            )
        st.text_input(
            "panaroo_opts (append)",
            value=st.session_state.get("bt_panaroo_opts", ""),
            key="bt_panaroo_opts",
        )

    # PIRATE (visible if engine == PIRATE)
    if st.session_state.get("bt_pangenome_engine", "Panaroo") == "PIRATE":
        help_header("_PIRATE_", "pirate", ratio=(3, 1))
        r1c, r2c, r3c, r4c = st.columns(4)
        with r1c:
            st.text_input(
                "--steps (e.g. 50,60,70,80,90,95,98)",
                value=st.session_state.get("bt_pirate_steps", ""),
                key="bt_pirate_steps",
            )
        with r2c:
            st.text_input(
                "--features (e.g. CDS)",
                value=st.session_state.get("bt_pirate_features", ""),
                key="bt_pirate_features",
            )
        with r3c:
            st.checkbox(
                "--para_off (disable paralog identification)",
                value=st.session_state.get("bt_pirate_para_off", False),
                key="bt_pirate_para_off",
            )
        with r4c:
            st.checkbox(
                "--z (keep intermediate files)",
                value=st.session_state.get("bt_pirate_z", False),
                key="bt_pirate_z",
            )
        st.text_input(
            "pan_opt (append for engine)",
            value=st.session_state.get("bt_pirate_opts", ""),
            key="bt_pirate_opts",
        )

    # Roary (visible if engine == Roary)
    if st.session_state.get("bt_pangenome_engine", "Panaroo") == "Roary":
        help_header("_Roary_", "roary", ratio=(3, 1))
        t1, t2, t3, t4 = st.columns(4)
        with t1:
            st.checkbox(
                "--use_prank",
                value=st.session_state.get("bt_roary_use_prank", False),
                key="bt_roary_use_prank",
            )
        with t2:
            st.text_input(
                "--i (identity %, e.g. 95)",
                value=st.session_state.get("bt_roary_i", ""),
                key="bt_roary_i",
            )
        with t3:
            st.text_input(
                "--cd (% core definition, e.g. 99)",
                value=st.session_state.get("bt_roary_cd", ""),
                key="bt_roary_cd",
            )
        with t4:
            st.text_input(
                "--g (max clusters, e.g. 50000)",
                value=st.session_state.get("bt_roary_g", ""),
                key="bt_roary_g",
            )
        u1, u2 = st.columns(2)
        with u1:
            st.checkbox(
                "--s (do not split paralogs)",
                value=st.session_state.get("bt_roary_s", False),
                key="bt_roary_s",
            )
        with u2:
            st.checkbox(
                "--ap (paralogs in core)",
                value=st.session_state.get("bt_roary_ap", False),
                key="bt_roary_ap",
            )
        st.text_input(
            "--iv (MCL inflation, e.g. 1.5)",
            value=st.session_state.get("bt_roary_iv", ""),
            key="bt_roary_iv",
        )

    # Prokka
    help_header("_Prokka (optional)_", "prokka", ratio=(3, 1))
    st.text_input(
        "--proteins (FASTA; optional)",
        value=st.session_state.get("bt_prokka_proteins", ""),
        key="bt_prokka_proteins",
    )
    st.text_input(
        "prokka_opts (append)",
        value=st.session_state.get("bt_prokka_opts", ""),
        key="bt_prokka_opts",
    )

    # Scoary & SNP-dists
    help_header("_Scoary & SNP-dists_", "scoary_snpdists", ratio=(3, 1))
    s1, s2, s3, s4 = st.columns(4)
    with s1:
        st.text_input(
            "--traits (CSV/TSV)",
            value=st.session_state.get("bt_scoary_traits", ""),
            key="bt_scoary_traits",
        )
    with s2:
        st.text_input(
            "--p_value_cutoff",
            value=st.session_state.get("bt_scoary_p_value_cutoff", ""),
            key="bt_scoary_p_value_cutoff",
        )
    with s3:
        st.text_input(
            "--correction",
            value=st.session_state.get("bt_scoary_correction", ""),
            key="bt_scoary_correction",
        )
    with s4:
        st.text_input(
            "--start_col",
            value=st.session_state.get("bt_scoary_start_col", ""),
            key="bt_scoary_start_col",
        )
    st.checkbox(
        "Scoary: --permute (permute phenotypes)",
        value=st.session_state.get("bt_scoary_permute", False),
        key="bt_scoary_permute",
    )
    st.checkbox("SNP-dists: --csv", value=st.session_state.get("bt_snpdists_csv", False), key="bt_snpdists_csv")

# --- Mashtree ---
if st.session_state.get("bt_run_mashtree"):
    help_header("**Mashtree ‚Äî options**", "mashtree")
    c1, c2, c3, c4 = st.columns(4)
    with c1:
        st.number_input(
            "--trunclength",
            0,
            1000000,
            value=st.session_state.get("bt_mashtree_trunclength", 0),
            step=100,
            key="bt_mashtree_trunclength",
        )
    with c2:
        st.text_input(
            "--sortorder (e.g. avg)",
            value=st.session_state.get("bt_mashtree_sortorder", ""),
            key="bt_mashtree_sortorder",
        )
    with c3:
        st.number_input(
            "--genomesize",
            0,
            100000000,
            value=st.session_state.get("bt_mashtree_genomesize", 0),
            step=100000,
            key="bt_mashtree_genomesize",
        )
    with c4:
        st.number_input(
            "--mindepth",
            0,
            100,
            value=st.session_state.get("bt_mashtree_mindepth", 0),
            step=1,
            key="bt_mashtree_mindepth",
        )
    c5, c6 = st.columns(2)
    with c5:
        st.number_input(
            "--kmerlength",
            1,
            64,
            value=st.session_state.get("bt_mashtree_kmerlength", 21),
            step=1,
            key="bt_mashtree_kmerlength",
        )
    with c6:
        st.number_input(
            "--sketchsize",
            1,
            200000,
            value=st.session_state.get("bt_mashtree_sketchsize", 10000),
            step=100,
            key="bt_mashtree_sketchsize",
        )
    st.checkbox(
        "--save_sketches",
        value=st.session_state.get("bt_mashtree_save_sketches", False),
        key="bt_mashtree_save_sketches",
    )

# ------------------------- Include file and command assembly -------------------------

def write_include_file(outdir: str, samples: List[str]) -> str:
    """
    Generate a temporary file for `--include`, with one sample per line.

    Args:
        outdir (str): Base output directory.
        samples (List[str]): List of sample names to include.

    Returns:
        str: Path to the generated include file.
    """
    ensure_state_dir()
    fname = APP_STATE_DIR / f"include_{hashlib.md5((outdir + '|' + ';'.join(samples)).encode()).hexdigest()[:10]}.txt"
    with open(fname, "w", encoding="utf-8") as fh:
        for s in samples:
            fh.write(s + "\n")
    return str(fname)

def bt_nextflow_cmd(
    tool: str,
    outdir: str,
    include_file: str,
    profile: str,
    threads: int | None = None,
    memory_gb: int | None = None,
    resume: bool = True,
    extra: List[str] | None = None,
) -> str:
    """
    Build the Nextflow command for a specific Bactopia Tool.

    Args:
        tool (str): Name of the tool (e.g., 'amrfinderplus').
        outdir (str): Bactopia results directory.
        include_file (str): Path to file with list of samples.
        profile (str): Nextflow profile (e.g., 'docker').
        threads (int | None): Max CPUs.
        memory_gb (int | None): Max memory in GB.
        resume (bool): Whether to use '-resume'.
        extra (List[str] | None): Additional arguments.

    Returns:
        str: The full shell command.
    """
    nf_bin = get_nextflow_bin()
    base = [
        nf_bin,
        "run",
        "bactopia/bactopia",
        "-profile",
        profile,
        "--wf",
        tool,
        "--bactopia",
        outdir,
        "--include",
        include_file,
    ]
    if threads and threads > 0:
        base += ["--max_cpus", str(threads)]
    if memory_gb and memory_gb > 0:
        base += ["--max_memory", f"{memory_gb}.GB"]
    if resume:
        base += ["-resume"]
    if extra:
        base += extra
    if (st.session_state.get("bt_extra") or "").strip():
        base += shlex.split(st.session_state["bt_extra"])
    return " ".join(shlex.quote(x) for x in base)

# ------------------------- Action bar (async execution) -------------------------
st.divider()
col1, col2 = st.columns([1, 1])
with col1:
    start_tools = st.button(
        "‚ñ∂Ô∏è Run Tools (async)",
        key="btn_tools_start",
        disabled=st.session_state.get("tools_running", False),
    )
with col2:
    stop_tools = st.button(
        "‚èπÔ∏è Stop",
        key="btn_tools_stop",
        disabled=not st.session_state.get("tools_running", False),
    )

status_box_tools = st.empty()
log_zone_tools = st.empty()

if stop_tools:
    request_stop_ns("tools")
    status_box_tools.warning("Stop requested‚Ä¶")

if start_tools:
    if not nextflow_available():
        st.error("Nextflow not found (not in PATH, nor in BACTOPIA_ENV_PREFIX / NEXTFLOW_BIN / nextflow_bin).")
    else:
        if not bt_outdir:
            st.error("Define the 'Bactopia results folder'.")
        else:
            if not sel and samples:
                sel = samples
                st.session_state["bt_selected_samples"] = sel
            if not sel:
                st.error("Select at least one sample.")
            else:
                include_file = write_include_file(bt_outdir, sel)
                tools_to_run: List[tuple[str, List[str]]] = []

                # AMRFinderPlus
                if st.session_state.get("bt_run_amrfinderplus"):
                    extra: List[str] = []
                    if st.session_state.get("bt_amrfinderplus_plus"):
                        extra.append("--amrfinderplus_plus")
                    if st.session_state.get("bt_amrfinderplus_mutation_all"):
                        extra.append("--amrfinderplus_mutation_all")
                    v = st.session_state.get("bt_amrfinderplus_ident_min")
                    if v not in (None, ""):
                        extra += ["--amrfinderplus_ident_min", str(v)]
                    v = st.session_state.get("bt_amrfinderplus_coverage_min")
                    if v not in (None, ""):
                        extra += ["--amrfinderplus_coverage_min", str(v)]
                    v = (st.session_state.get("bt_amrfinderplus_organism", "")).strip()
                    if v:
                        extra += ["--amrfinderplus_organism", v]
                    if st.session_state.get("bt_amrfinderplus_report_common"):
                        extra.append("--amrfinderplus_report_common")
                    if st.session_state.get("bt_amrfinderplus_report_all_equal_best"):
                        extra.append("--amrfinderplus_report_all_equal_best")
                    if st.session_state.get("bt_amrfinderplus_allow_overlap"):
                        extra.append("--amrfinderplus_allow_overlap")
                    if st.session_state.get("bt_amrfinderplus_exclude_quick_need_prediction"):
                        extra.append("--amrfinderplus_exclude_quick_need_prediction")
                    v = (st.session_state.get("bt_amrfinderplus_extra", "")).strip()
                    if v:
                        extra += shlex.split(v)
                    tools_to_run.append(("amrfinderplus", extra))

                # RGI
                if st.session_state.get("bt_run_rgi"):
                    extra = []
                    if st.session_state.get("bt_rgi_use_diamond"):
                        extra.append("--rgi_use_diamond")
                    if st.session_state.get("bt_rgi_include_loose"):
                        extra.append("--rgi_include_loose")
                    if st.session_state.get("bt_rgi_exclude_nudge"):
                        extra.append("--rgi_exclude_nudge")
                    for k, flag in [
                        ("bt_rgi_frequency", "--rgi_frequency"),
                        ("bt_rgi_category", "--rgi_category"),
                        ("bt_rgi_cluster", "--rgi_cluster"),
                        ("bt_rgi_display", "--rgi_display"),
                    ]:
                        v = (st.session_state.get(k) or "").strip()
                        if v:
                            extra += [flag, v]
                    v = (st.session_state.get("bt_rgi_extra", "")).strip()
                    if v:
                        extra += shlex.split(v)
                    tools_to_run.append(("rgi", extra))

                # ABRicate
                if st.session_state.get("bt_run_abricate"):
                    extra = []
                    if (st.session_state.get("bt_abricate_db") or "").strip():
                        extra += ["--abricate_db", st.session_state["bt_abricate_db"]]
                    tools_to_run.append(("abricate", extra))

                # MobSuite
                if st.session_state.get("bt_run_mobsuite"):
                    tools_to_run.append(("mobsuite", []))

                # MLST
                if st.session_state.get("bt_run_mlst"):
                    extra = []
                    v = (st.session_state.get("bt_mlst_scheme", "")).strip()
                    if v:
                        extra += ["--scheme", v]
                    v = st.session_state.get("bt_mlst_minid")
                    if v not in (None, ""):
                        extra += ["--minid", str(v)]
                    v = st.session_state.get("bt_mlst_mincov")
                    if v not in (None, ""):
                        extra += ["--mincov", str(v)]
                    v = st.session_state.get("bt_mlst_minscore")
                    if v not in (None, ""):
                        extra += ["--minscore", str(v)]
                    if st.session_state.get("bt_mlst_nopath"):
                        extra.append("--nopath")
                    tools_to_run.append(("mlst", extra))

                # PlasmidFinder
                if st.session_state.get("bt_run_plasmidfinder"):
                    extra = []
                    v = st.session_state.get("bt_pf_mincov")
                    if v not in (None, ""):
                        extra += ["--pf_mincov", str(v)]
                    v = st.session_state.get("bt_pf_threshold")
                    if v not in (None, ""):
                        extra += ["--pf_threshold", str(v)]
                    v = (st.session_state.get("bt_plasmidfinder_extra", "")).strip()
                    if v:
                        extra += shlex.split(v)
                    tools_to_run.append(("plasmidfinder", extra))

                # Pangenome
                if st.session_state.get("bt_run_pangenome"):
                    extra = []

                    # Engine (Panaroo is default)
                    engine = st.session_state.get("bt_pangenome_engine", "Panaroo")
                    if engine == "PIRATE":
                        extra.append("--use_pirate")
                    elif engine == "Roary":
                        extra.append("--use_roary")

                    # Extra filters (‚ö†Ô∏è a second --include may overwrite the global include_file)
                    inc = (st.session_state.get("bt_pangenome_include") or "").strip()
                    exc = (st.session_state.get("bt_pangenome_exclude") or "").strip()
                    if inc:
                        extra += ["--include", inc]
                    if exc:
                        extra += ["--exclude", exc]

                    # NCBI genome download
                    species = (st.session_state.get("bt_pangenome_species") or "").strip()
                    accessions = (st.session_state.get("bt_pangenome_accessions") or "").strip()
                    if species:
                        extra += ["--species", species]
                    if accessions:
                        extra += ["--accessions", accessions]

                    # ClonalFrameML
                    if st.session_state.get("bt_pangenome_skip_recombination", False):
                        extra.append("--skip_recombination")

                    # IQ-TREE
                    v = (st.session_state.get("bt_iqtree_model", "")).strip()
                    if v:
                        extra += ["--iqtree_model", v]
                    v = st.session_state.get("bt_iqtree_bb", 0)
                    if v:
                        extra += ["--bb", str(int(v))]
                    v = st.session_state.get("bt_iqtree_alrt", 0)
                    if v:
                        extra += ["--alrt", str(int(v))]
                    if st.session_state.get("bt_iqtree_asr"):
                        extra.append("--asr")
                    v = (st.session_state.get("bt_iqtree_opts", "")).strip()
                    if v:
                        extra += ["--iqtree_opts", v]

                    # Panaroo params (only if engine == Panaroo)
                    if engine == "Panaroo":
                        for key, flag in [
                            ("bt_panaroo_mode", "--panaroo_mode"),
                            ("bt_panaroo_alignment", "--panaroo_alignment"),
                            ("bt_panaroo_aligner", "--panaroo_aligner"),
                            ("bt_panaroo_core_threshold", "--panaroo_core_threshold"),
                            ("bt_panaroo_threshold", "--panaroo_threshold"),
                            ("bt_panaroo_family_threshold", "--panaroo_family_threshold"),
                            ("bt_panaroo_len_dif_percent", "--len_dif_percent"),
                        ]:
                            vv = (st.session_state.get(key) or "").strip()
                            if vv:
                                extra += [flag, vv]
                        if st.session_state.get("bt_panaroo_merge_paralogs"):
                            extra.append("--merge_paralogs")
                        v = (st.session_state.get("bt_panaroo_opts", "")).strip()
                        if v:
                            extra += ["--panaroo_opts", v]

                    # PIRATE params
                    if engine == "PIRATE":
                        steps = (st.session_state.get("bt_pirate_steps") or "").strip()
                        features = (st.session_state.get("bt_pirate_features") or "").strip()
                        para_off = st.session_state.get("bt_pirate_para_off", False)
                        keep_z = st.session_state.get("bt_pirate_z", False)
                        pan_opt = (st.session_state.get("bt_pirate_opts") or "").strip()
                        if steps:
                            extra += ["--steps", steps]
                        if features:
                            extra += ["--features", features]
                        if para_off:
                            extra.append("--para_off")
                        if keep_z:
                            extra.append("--z")
                        if pan_opt:
                            extra += ["--pan_opt", pan_opt]

                    # Roary params
                    if engine == "Roary":
                        if st.session_state.get("bt_roary_use_prank"):
                            extra.append("--use_prank")
                        for key, flag in [
                            ("bt_roary_i", "--i"),
                            ("bt_roary_cd", "--cd"),
                            ("bt_roary_g", "--g"),
                            ("bt_roary_iv", "--iv"),
                        ]:
                            vv = (st.session_state.get(key) or "").strip()
                            if vv:
                                extra += [flag, vv]
                        if st.session_state.get("bt_roary_s"):
                            extra.append("--s")
                        if st.session_state.get("bt_roary_ap"):
                            extra.append("--ap")

                    # Prokka
                    v = (st.session_state.get("bt_prokka_proteins", "")).strip()
                    if v:
                        extra += ["--proteins", v]
                    v = (st.session_state.get("bt_prokka_opts", "")).strip()
                    if v:
                        extra += ["--prokka_opts", v]

                    # Scoary & SNP-dists
                    v = (st.session_state.get("bt_scoary_traits", "")).strip()
                    if v:
                        extra += ["--traits", v]
                    for key, flag in [
                        ("bt_scoary_p_value_cutoff", "--p_value_cutoff"),
                        ("bt_scoary_correction", "--correction"),
                        ("bt_scoary_start_col", "--start_col"),
                    ]:
                        vv = (st.session_state.get(key) or "").strip()
                        if vv:
                            extra += [flag, vv]
                    if st.session_state.get("bt_scoary_permute"):
                        extra += ["--permute"]
                    if st.session_state.get("bt_snpdists_csv"):
                        extra += ["--csv"]

                    tools_to_run.append(("pangenome", extra))

                # Mashtree
                if st.session_state.get("bt_run_mashtree"):
                    extra = []
                    for key, flag in [
                        ("bt_mashtree_trunclength", "--trunclength"),
                        ("bt_mashtree_sortorder", "--sortorder"),
                        ("bt_mashtree_genomesize", "--genomesize"),
                        ("bt_mashtree_mindepth", "--mindepth"),
                        ("bt_mashtree_kmerlength", "--kmerlength"),
                        ("bt_mashtree_sketchsize", "--sketchsize"),
                    ]:
                        vv = st.session_state.get(key)
                        if isinstance(vv, (int, float)) and vv > 0:
                            extra += [flag, str(vv)]
                        elif isinstance(vv, str) and vv.strip():
                            extra += [flag, vv.strip()]
                    if st.session_state.get("bt_mashtree_save_sketches"):
                        extra.append("--save_sketches")
                    tools_to_run.append(("mashtree", extra))

                if not tools_to_run:
                    st.warning("Select at least one official tool.")
                else:
                    sub_cmds = []
                    stdbuf = shutil.which("stdbuf")
                    for tool, extra in tools_to_run:
                        cmdi = bt_nextflow_cmd(
                            tool,
                            bt_outdir,
                            include_file,
                            st.session_state.get("bt_profile", "docker"),
                            st.session_state.get("bt_threads") or None,
                            st.session_state.get("bt_memory_gb") or None,
                            resume=st.session_state.get("bt_resume", True),
                            extra=extra,
                        )
                        if stdbuf:
                            cmdi = f"{stdbuf} -oL -eL {cmdi}"
                        sub_cmds.append(f'echo "===== [Bactopia Tool] {tool} =====" ; {cmdi}')
                    full_cmd = " ; ".join(sub_cmds)
                    status_box_tools.info("Running tools (async).")
                    start_async_runner_ns(full_cmd, "tools")

# Real-time log update
if st.session_state.get("tools_running", False):
    drain_log_queue_ns("tools", tail_limit=500, max_pull=800)
    render_log_box_ns("tools", height=520)
    finished = check_status_and_finalize_ns("tools", status_box_tools)
    if not finished:
        time.sleep(0.3)
        _st_rerun()
else:
    render_log_box_ns("tools", height=520)

# ------------------------- merged-results -------------------------
st.divider()
st.subheader("merged-results (recent runs)")

runs_root = pathlib.Path(bt_outdir) / "bactopia-runs" if bt_outdir else None
if runs_root and runs_root.exists():
    runs = sorted(runs_root.glob("*"))
    if runs:
        latest = runs[-1]
        mr = latest / "merged-results"
        if mr.exists():
            for f in sorted(mr.glob("*.tsv")):
                st.markdown(f"- `{f.name}` ‚Äî {f}")
        else:
            st.caption("No merged-results found in this run.")
    else:
        st.caption("There are no runs in bactopia-runs yet.")
else:
    st.caption("bactopia-runs directory not found.")

DISCLAIMER_MD = """
> ‚ö†Ô∏è **Notice about Bactopia**
>
> This panel only orchestrates official **Bactopia** pipeline.  
> Bactopia is software developed by third parties (https://bactopia.github.io/latest/).  
> **BEAR-HUB** does not modify Bactopia's code; it only assembles commands
> and parameters in a more user-friendly way.
>
> For methods, limitations, and the correct way to cite Bactopia, always refer
> to the official documentation and repository.
"""

st.markdown(DISCLAIMER_MD)
