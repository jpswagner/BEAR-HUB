# BACTOPIA-TOOLS.py â€” Bactopia Local UI (Official tools via --wf)
# ---------------------------------------------------------------------
# â€¢ Streamlit interface to orchestrate **Bactopia Tools** (via Nextflow `--wf`)
# â€¢ Focused on results already generated by Bactopia (folder with samples)
# â€¢ Allows batch execution of official tools such as:
#     - amrfinderplus, rgi, abricate, mobsuite, mlst
#     - pangenome (Panaroo/PIRATE/Roary + IQ-TREE + Prokka + Scoary + SNP-dists)
#     - mashtree, plasmidfinder
# â€¢ Asynchronous execution with log tailing (Nextflow)
# â€¢ Optional integration with the Bactopia conda environment via BACTOPIA_ENV_PREFIX
# â€¢ Can be used standalone:
#       streamlit run BACTOPIA-TOOLS.py
#   or as a page inside BEAR-HUB.
#
# âš ï¸ Important notice:
#   - **Bactopia** is developed by third parties (community/open source).
#   - **BEAR-HUB** only assembles and runs Nextflow/Bactopia commands
#     in a friendlier way, without modifying the pipeline code.
#   - Always refer to the official Bactopia documentation for methods,
#     limitations, and the correct way to cite the software.
# ---------------------------------------------------------------------

"""
Bactopia Tools Interface.

This module provides a UI for running "Bactopia Tools" (workflows that run on
already processed Bactopia samples). It handles:
1.  **Sample Discovery**: Scanning a Bactopia output directory to find valid samples.
2.  **Tool Selection**: Checkbox-based selection of tools like AMRFinderPlus, RGI, MLST, etc.
3.  **Configuration**: Setting parameters specific to each tool (e.g., identity thresholds, database paths).
4.  **Batch Execution**: Creating an `--include` file for selected samples and running the tools via Nextflow.
5.  **Monitoring**: Real-time log visualization.
"""

import os
import shlex
import time
import pathlib
import shutil
import hashlib
from typing import List

import streamlit as st

# Import utility module from parent directory (or same directory if running from root)
try:
    import utils
except ImportError:
    import sys
    sys.path.append(str(pathlib.Path(__file__).parent.parent))
    import utils

# ============================= General config =============================
st.set_page_config(
    page_title="Bactopia â€” Tools | BEAR-HUB",
    page_icon="ðŸ»",
    layout="wide",
)

APP_ROOT = pathlib.Path(__file__).resolve().parent
PAGES_DIR = APP_ROOT / "pages"
PAGE_BACTOPIA = PAGES_DIR / "BACTOPIA.py"
PAGE_TOOLS = PAGES_DIR / "BACTOPIA-TOOLS.py"
PAGE_MERLIN = PAGES_DIR / "MERLIN.py"
PAGE_PORT = PAGES_DIR / "PORT.py"

# Safely discover project root
if (APP_ROOT / "static").is_dir():
    PROJECT_ROOT = APP_ROOT
elif (APP_ROOT.parent / "static").is_dir():
    PROJECT_ROOT = APP_ROOT.parent
else:
    PROJECT_ROOT = APP_ROOT  # fallback

APP_STATE_DIR = pathlib.Path.home() / ".bactopia_ui_local"

# Default outdir aligned with BEAR-HUB (can be overridden by bt_outdir from main page)
DEFAULT_OUTDIR = str((pathlib.Path.home() / "BEAR_DATA" / "bactopia_out").resolve())

# ===================== Nextflow via Bactopia environment =====================

# Try to load .bear-hub.env right at startup
utils.bootstrap_bear_env_from_file()

BACTOPIA_ENV_PREFIX = os.environ.get("BACTOPIA_ENV_PREFIX")

# ============================= Helps (popovers) =============================

def help_popover(label: str, text: str):
    """
    Show a help text inside a popover.

    Args:
        label (str): Label for the popover button.
        text (str): Markdown text content.
    """
    with st.popover(label):
        st.markdown(text)

def help_header(title_md: str, help_key: str, ratio=(4, 1)):
    """
    Render a header row with a help button.

    Args:
        title_md (str): Markdown title string.
        help_key (str): Key to look up help text in the HELP dictionary.
        ratio (tuple): Ratio of column widths for title vs help button.
    """
    c1, c2 = st.columns(ratio)
    with c1:
        st.markdown(title_md)
    with c2:
        help_popover("â“ Help", HELP[help_key])


HELP = {}

HELP["amostras"] = """
### Sample selection

- The list is inferred from the **folders** inside `--bactopia` (one folder per sample).
- The UI automatically generates an `--include` file with the selected samples.

### `--include` / `--exclude` (in the Pangenome section)

- These fields accept a **TXT file path**, with **one sample name per line** (e.g. `sampleA`).
- Names must match **exactly** the sample folders inside `--bactopia`.
- `--include` in the Pangenome section **overrides** the automatic include file generated by the UI.
- `--exclude` removes samples from the current set.
- Avoid commas or headers; empty lines are ignored. Prefer **absolute** paths.
"""

HELP["gerais"] = """
**General Nextflow/Bactopia parameters**

- **`-profile`**  
  Execution environment. Examples:
  - `docker` (Docker containers),
  - `singularity` (Apptainer),
  - `standard` (no containers).

- **`--max_cpus`**  
  Global thread limit for the Nextflow scheduler (not per task).

- **`--max_memory`**  
  Global memory limit, e.g. `64.GB`. Tasks that require more memory will wait in a queue.

- **`-resume`**  
  Reuses already completed steps via Nextflow's cache. Recommended to keep it **enabled**.

- **`Extras`**  
  Free-form field for additional flags:
  - extra Nextflow parameters (e.g. `-with-report report.html`)
  - extra Bactopia Tools parameters.
"""

HELP["pangenome"] = """
**`pangenome` workflow â€” overview**

- Input: samples already processed by Bactopia (`--bactopia`),
  using the GFF3 annotation files.
- You may include **RefSeq references** via `--species` or `--accessions`.
- Available engines:
  - **Panaroo** (default; graph-based, robust to fragmented genomes).
  - **PIRATE** (clustering across multiple identity thresholds).
  - **Roary** (classic/faster).

**Typical output**

- Gene presence/absence matrix.
- Core genome + alignment.
- Tree built with **IQ-TREE** (optionally masking recombination).
- Distances with `snp-dists` and geneâ€“phenotype association with **Scoary**.

**Good practices**

- Use `--species` *or* `--accessions` to anchor on canonical references.
- Enable `--skip_recombination` only if recombination is not relevant.
- For stronger branch support: configure `--bb` (bootstrap) and/or `--alrt`.
"""

HELP["iqtree"] = """
**IQ-TREE (phylogeny)**

- **`--iqtree_model`**  
  Substitution model (e.g. `GTR+G`).  
  If left blank, IQ-TREE chooses automatically (*ModelFinder*).

- **`--bb`**  
  *Ultrafast bootstrap* (e.g. `1000`).  
  Higher values give more stable support but increase runtime.

- **`--alrt`**  
  *Approximate Likelihood Ratio Test* (e.g. `1000`).  
  Can be used together with or instead of bootstrap.

- **`--asr`**  
  Enables ancestral state reconstruction.

- **`--iqtree_opts`**  
  Free-form field for additional IQ-TREE options (e.g. `-nt AUTO --safe`).
"""

HELP["panaroo"] = """
**Panaroo (engine)**

- **`--panaroo_mode`**: execution mode (`strict`, `sensitive`, ...).
- **`--panaroo_alignment`**: which genes to align (e.g. `core`, `all`).
- **`--panaroo_aligner`**: aligner (e.g. `mafft`).
- **`--panaroo_core_threshold`**: minimum fraction for a gene to be considered *core* (e.g. `0.95`).
- **`--panaroo_threshold`**: minimum identity for orthologs.
- **`--panaroo_family_threshold`**: minimum identity for families.
- **`--len_dif_percent`**: length difference tolerance.
- **`--merge_paralogs`**: attempts to merge paralogs.
- **`panaroo_opts`**: extra options passed directly to Panaroo.
"""

HELP["pirate"] = """
**PIRATE (engine)**

- **`--steps`**: list of identity thresholds for clustering (e.g. `50,60,70,80,90,95,98`).
- **`--features`**: feature types (e.g. `CDS`).
- **`--para_off`**: disables paralog identification.
- **`--z`**: keeps intermediate files.
- **`pan_opt`**: raw options forwarded to PIRATE.
"""

HELP["roary"] = """
**Roary (engine)**

- **`--i`**: minimum BLASTp identity (%), e.g. `95`.
- **`--cd`**: minimum percentage for core definition (e.g. `99`).
- **`--g`**: maximum number of gene families (e.g. `50000`).
- **`--iv`**: MCL inflation parameter (controls clustering granularity).
- **`--s`**: do not split paralogs.
- **`--ap`**: allow paralogs in the core.
- **`--use_prank`**: use PRANK for gene alignments.
"""

HELP["prokka"] = """
**Prokka (reference re-annotation)**

- **`--proteins`**: FASTA with reference proteins to guide annotations.
- **`prokka_opts`**: free-form Prokka options (e.g. `--kingdom Bacteria --genus Escherichia`).
"""

HELP["scoary_snpdists"] = """
**Scoary & SNP-dists**

- **Scoary**
  - **`--traits`**: CSV/TSV with phenotypes (sample names must match the pangenome).
  - **`--p_value_cutoff`**, `--correction`, `--start_col`:
    control significance and how phenotype columns are parsed.
  - **`--permute`**: enables random phenotype permutations (slower; useful for empirical significance).

- **SNP-dists**
  - Computes distance matrix from the alignment.
  - **`--csv`**: exports CSV in addition to TSV.
"""

HELP["amrfinderplus"] = """
**AMRFinderPlus**

- Detects **resistance** and **virulence** genes/mutations.
- Main flags:
  - **`--plus`**: includes additional targets.
  - **`--mutation_all`**: reports relevant SNPs.
  - **`--ident_min`** / **`--coverage_min`**:
    identity/coverage thresholds.
  - **`--organism`**:
    restricts searches to a specific taxon (improves specificity).
- The â€œAMRFinderPlus extrasâ€ field accepts additional raw options.
"""

HELP["rgi"] = """
**RGI (CARD)**

- Predicts **AMR** using the CARD database.
- Common options:
  - **`--use_diamond`**: speeds up search using DIAMOND (recommended).
  - **`--include_loose`**: includes *loose hits*.
  - **`--exclude_nudge`**: removes *nudged hits*.
  - **`--frequency`**, `--category`, `--cluster`, `--display`:
    further control filters and output format.
"""

HELP["mlst"] = """
**MLST**

- **`--scheme`**: scheme name (e.g. `ecoli`, `staphylococcus_aureus`).
- **`--minid`**, `--mincov`, `--minscore`:
  minimum identity, coverage and score to accept a ST.
- **`--nopath`**: disables pathway resolution in specific schemes.
"""

HELP["mashtree"] = """
**Mashtree**

- Builds fast trees using Mash *sketches*.
- Main parameters:
  - **`--kmerlength`**, `--sketchsize`:
    control resolution and computational cost.
  - **`--trunclength`**, `--genomesize`:
    control truncation and expected genome size.
  - **`--mindepth`**, `--sortorder`:
    fine tuning of the build/order.
  - **`--save_sketches`**: saves sketches for reuse.
"""

HELP["plasmidfinder"] = """
**PlasmidFinder**

- Identifies replicons/plasmids in bacterial genomes.
- Main parameters:
  - **`--pf_mincov`**:
    minimum coverage (0â€“1; e.g. `0.6` = 60%) to consider a hit.
  - **`--pf_threshold`**:
    minimum identity (0â€“1; e.g. `0.9` = 90%) to consider a hit.
- The â€œPlasmidFinder extrasâ€ field accepts additional options supported by Bactopia Tools.
"""

# ============================= Utils =============================

def have_tool(name: str) -> bool:
    """Check if a specific tool is in PATH."""
    return utils.which(name) is not None

# ============================= Page =============================

ICON_PATH = PROJECT_ROOT / "static" / "bear-hub-icon.png"
ICON_PATH_BACTOPIA_TOOLS = PROJECT_ROOT / "static" / "BEAR-BACTOPIA-TOOLS.png"

if ICON_PATH_BACTOPIA_TOOLS.is_file():
    st.image(str(ICON_PATH_BACTOPIA_TOOLS), width=500)
else:
    st.title("ðŸ§° Bactopia â€” Official Tools")

# ------------------------- Folder/sample selection -------------------------
st.subheader("Folder and sample selection")
help_popover("â“ Help", HELP["amostras"])


bt_root_default = utils.guess_bactopia_root_default(PROJECT_ROOT)

# bt_outdir is initially defined only here, so we don't fight with the widget
if "bt_outdir" not in st.session_state or not st.session_state["bt_outdir"]:
    st.session_state["bt_outdir"] = bt_root_default

bt_outdir = utils.path_picker(
    "Bactopia results folder",
    key="bt_outdir",
    mode="dir",
    start=bt_root_default,
    help="Folder that contains Bactopia sample folders (one folder per sample).",
)
# if the user clears the field, fall back to the computed default
bt_outdir = bt_outdir or bt_root_default
bt_outdir = str(pathlib.Path(bt_outdir).expanduser().resolve())
st.caption(f"Current directory: `{bt_outdir}`")

# Detect folder change to force selection of all samples
prev_bt_outdir = st.session_state.get("_prev_bt_outdir")
folder_changed = prev_bt_outdir is not None and prev_bt_outdir != bt_outdir
st.session_state["_prev_bt_outdir"] = bt_outdir

# Discover samples inside the current bt_outdir
samples = utils.discover_samples_from_outdir(bt_outdir) if bt_outdir else []

if samples:
    prev_sel = st.session_state.get("bt_selected_samples", [])
    if not isinstance(prev_sel, list):
        prev_sel = []

    if folder_changed:
        # If the folder changed, select ALL samples automatically
        default_sel = samples.copy()
    else:
        # If the folder is the same, keep intersection with current options
        default_sel = [s for s in prev_sel if s in samples]
        if not default_sel:
            default_sel = samples.copy()

    st.session_state["bt_selected_samples"] = default_sel

    sel = st.multiselect(
        "Samples",
        options=samples,
        default=default_sel,
        key="bt_selected_samples",
    )
else:
    sel = []
    if bt_outdir:
        st.warning("No samples found in this folder.")

st.divider()
st.subheader("Bactopia tools")

r1 = st.columns(5)
with r1[0]:
    st.checkbox("amrfinderplus", value=st.session_state.get("bt_run_amrfinderplus", False), key="bt_run_amrfinderplus")
with r1[1]:
    st.checkbox("rgi", value=st.session_state.get("bt_run_rgi", False), key="bt_run_rgi")
with r1[2]:
    st.checkbox("abricate", value=st.session_state.get("bt_run_abricate", False), key="bt_run_abricate")
with r1[3]:
    st.checkbox("mobsuite", value=st.session_state.get("bt_run_mobsuite", False), key="bt_run_mobsuite")
with r1[4]:
    st.checkbox("mlst", value=st.session_state.get("bt_run_mlst", False), key="bt_run_mlst")

r2 = st.columns(5)
with r2[0]:
    st.checkbox("pangenome", value=st.session_state.get("bt_run_pangenome", False), key="bt_run_pangenome")
with r2[1]:
    st.checkbox("mashtree", value=st.session_state.get("bt_run_mashtree", False), key="bt_run_mashtree")
with r2[2]:
    st.checkbox("plasmidfinder", value=st.session_state.get("bt_run_plasmidfinder", False), key="bt_run_plasmidfinder")

# ------------------------- General parameters -------------------------
with st.expander("General parameters", expanded=True):
    bt_profile = st.selectbox("Profile (-profile)", ["docker", "singularity", "standard"], index=0, key="bt_profile")
    bt_threads = st.slider("--max_cpus", 0, min(os.cpu_count() or 64, 128), 0, 1, key="bt_threads")
    bt_memory_gb = st.slider("--max_memory (GB)", 0, 256, 0, 1, key="bt_memory_gb")
    bt_resume = st.checkbox("-resume", value=True, key="bt_resume")
    bt_extra = st.text_input(
        "Extras (raw line, optional)",
        key="bt_extra",
        value=st.session_state.get("bt_extra", ""),
        help="Additional flags for Nextflow/Bactopia (e.g. -with-report, global parameters, etc.).",
    )
    help_popover("â“ Help (general parameters)", HELP["gerais"])

# ------------------------- Tool-specific options -------------------------

# ABRicate
if st.session_state.get("bt_run_abricate"):
    st.markdown("**ABRicate â€” options**")
    st.text_input(
        "--abricate_db (e.g. ncbi,plasmidfinder)",
        key="bt_abricate_db",
        value=st.session_state.get("bt_abricate_db", ""),
    )

# --- AMRFinderPlus ---
if st.session_state.get("bt_run_amrfinderplus"):
    help_header("**AMRFinderPlus â€” options**", "amrfinderplus")
    c1, c2, c3 = st.columns(3)
    with c1:
        st.checkbox("--plus", value=st.session_state.get("bt_amrfinderplus_plus", True), key="bt_amrfinderplus_plus")
        st.checkbox(
            "--mutation_all",
            value=st.session_state.get("bt_amrfinderplus_mutation_all", False),
            key="bt_amrfinderplus_mutation_all",
        )
    with c2:
        st.number_input(
            "--ident_min",
            0.0,
            100.0,
            value=st.session_state.get("bt_amrfinderplus_ident_min", 90.0),
            step=0.5,
            key="bt_amrfinderplus_ident_min",
        )
        st.number_input(
            "--coverage_min",
            0.0,
            100.0,
            value=st.session_state.get("bt_amrfinderplus_coverage_min", 50.0),
            step=0.5,
            key="bt_amrfinderplus_coverage_min",
        )
    with c3:
        st.text_input(
            "--organism (e.g. Enterobacteriaceae)",
            value=st.session_state.get("bt_amrfinderplus_organism", ""),
            key="bt_amrfinderplus_organism",
        )
    c4, c5, c6 = st.columns(3)
    with c4:
        st.checkbox(
            "--report_common",
            value=st.session_state.get("bt_amrfinderplus_report_common", False),
            key="bt_amrfinderplus_report_common",
        )
    with c5:
        st.checkbox(
            "--report_all_equal_best",
            value=st.session_state.get("bt_amrfinderplus_report_all_equal_best", False),
            key="bt_amrfinderplus_report_all_equal_best",
        )
    with c6:
        st.checkbox(
            "--allow_overlap",
            value=st.session_state.get("bt_amrfinderplus_allow_overlap", False),
            key="bt_amrfinderplus_allow_overlap",
        )
    st.checkbox(
        "--exclude_quick_need_prediction",
        value=st.session_state.get("bt_amrfinderplus_exclude_quick_need_prediction", False),
        key="bt_amrfinderplus_exclude_quick_need_prediction",
    )
    st.text_input(
        "AMRFinderPlus extras (raw line/append)",
        value=st.session_state.get("bt_amrfinderplus_extra", ""),
        key="bt_amrfinderplus_extra",
    )

# --- RGI ---
if st.session_state.get("bt_run_rgi"):
    help_header("**RGI (CARD) â€” options**", "rgi")
    c1, c2, c3, c4 = st.columns(4)
    with c1:
        st.checkbox("--use_diamond", value=st.session_state.get("bt_rgi_use_diamond", True), key="bt_rgi_use_diamond")
    with c2:
        st.checkbox(
            "--include_loose",
            value=st.session_state.get("bt_rgi_include_loose", False),
            key="bt_rgi_include_loose",
        )
    with c3:
        st.checkbox(
            "--exclude_nudge",
            value=st.session_state.get("bt_rgi_exclude_nudge", False),
            key="bt_rgi_exclude_nudge",
        )
    with c4:
        st.text_input(
            "--frequency (e.g. 'perfect,strict')",
            value=st.session_state.get("bt_rgi_frequency", ""),
            key="bt_rgi_frequency",
        )
    c5, c6, c7 = st.columns(3)
    with c5:
        st.text_input("--category", value=st.session_state.get("bt_rgi_category", ""), key="bt_rgi_category")
    with c6:
        st.text_input("--cluster", value=st.session_state.get("bt_rgi_cluster", ""), key="bt_rgi_cluster")
    with c7:
        st.text_input("--display", value=st.session_state.get("bt_rgi_display", ""), key="bt_rgi_display")
    st.text_input(
        "RGI extras (raw line/append)",
        value=st.session_state.get("bt_rgi_extra", ""),
        key="bt_rgi_extra",
    )

# --- MLST ---
if st.session_state.get("bt_run_mlst"):
    help_header("**MLST â€” options**", "mlst")
    c1, c2, c3, c4, c5 = st.columns(5)
    with c1:
        st.text_input("--scheme", value=st.session_state.get("bt_mlst_scheme", ""), key="bt_mlst_scheme")
    with c2:
        st.number_input(
            "--minid",
            0.0,
            100.0,
            value=st.session_state.get("bt_mlst_minid", 95.0),
            step=0.5,
            key="bt_mlst_minid",
        )
    with c3:
        st.number_input(
            "--mincov",
            0.0,
            100.0,
            value=st.session_state.get("bt_mlst_mincov", 50.0),
            step=0.5,
            key="bt_mlst_mincov",
        )
    with c4:
        st.number_input(
            "--minscore",
            0.0,
            100.0,
            value=st.session_state.get("bt_mlst_minscore", 0.0),
            step=0.5,
            key="bt_mlst_minscore",
        )
    with c5:
        st.checkbox("--nopath", value=st.session_state.get("bt_mlst_nopath", False), key="bt_mlst_nopath")

# --- PlasmidFinder ---
if st.session_state.get("bt_run_plasmidfinder"):
    help_header("**PlasmidFinder â€” options**", "plasmidfinder")
    c1, c2 = st.columns(2)
    with c1:
        st.number_input(
            "--pf_mincov (0â€“1, e.g. 0.6)",
            0.0,
            1.0,
            value=st.session_state.get("bt_pf_mincov", 0.6),
            step=0.05,
            key="bt_pf_mincov",
        )
    with c2:
        st.number_input(
            "--pf_threshold (0â€“1, e.g. 0.9)",
            0.0,
            1.0,
            value=st.session_state.get("bt_pf_threshold", 0.9),
            step=0.05,
            key="bt_pf_threshold",
        )
    st.text_input(
        "PlasmidFinder extras (raw line/append)",
        value=st.session_state.get("bt_plasmidfinder_extra", ""),
        key="bt_plasmidfinder_extra",
    )

# --- Pangenome subset ---
if st.session_state.get("bt_run_pangenome"):
    help_header("**Pangenome â€” main options**", "pangenome")
    st.caption(
        "Includes engine (Panaroo/PIRATE/Roary) + IQ-TREE + Prokka + Scoary + SNP-dists. "
        "Use global 'Extras' for additional Nextflow flags."
    )

    # Engine
    c1, c2 = st.columns([1, 3])
    with c1:
        st.radio(
            "Engine",
            options=["Panaroo", "PIRATE", "Roary"],
            index=["Panaroo", "PIRATE", "Roary"].index(
                st.session_state.get("bt_pangenome_engine", "Panaroo")
            ),
            key="bt_pangenome_engine",
        )
    with c2:
        help_popover("â„¹ï¸ Engine (Panaroo/PIRATE/Roary)", HELP["pangenome"])

    # Additional sample selection (pangenome only)
    st.markdown("_Extra sample selection (pangenome only; optional)_")
    cc1, cc2 = st.columns(2)
    with cc1:
        st.text_input(
            "--include file (one name per line) [âš ï¸ overrides automatic include]",
            value=st.session_state.get("bt_pangenome_include", ""),
            key="bt_pangenome_include",
        )
    with cc2:
        st.text_input(
            "--exclude file (one name per line)",
            value=st.session_state.get("bt_pangenome_exclude", ""),
            key="bt_pangenome_exclude",
        )

    # Downloaded references (RefSeq)
    st.markdown("_Reference genomes (RefSeq; optional)_")
    c3, c4 = st.columns(2)
    with c3:
        st.text_input(
            "--species (e.g. Escherichia coli)",
            value=st.session_state.get("bt_pangenome_species", ""),
            key="bt_pangenome_species",
        )
    with c4:
        st.text_input(
            "--accessions (file with 1 accession per line OR CSV)",
            value=st.session_state.get("bt_pangenome_accessions", ""),
            key="bt_pangenome_accessions",
        )

    # Recombination
    st.checkbox(
        "--skip_recombination (skip ClonalFrameML)",
        value=st.session_state.get("bt_pangenome_skip_recombination", False),
        key="bt_pangenome_skip_recombination",
    )

    # IQ-TREE
    help_header("_IQ-TREE_", "iqtree", ratio=(3, 1))
    q1, q2, q3, q4 = st.columns(4)
    with q1:
        st.text_input(
            "--iqtree_model",
            value=st.session_state.get("bt_iqtree_model", ""),
            key="bt_iqtree_model",
        )
    with q2:
        st.number_input(
            "--bb",
            0,
            5000,
            value=st.session_state.get("bt_iqtree_bb", 0),
            step=100,
            key="bt_iqtree_bb",
        )
    with q3:
        st.number_input(
            "--alrt",
            0,
            5000,
            value=st.session_state.get("bt_iqtree_alrt", 0),
            step=100,
            key="bt_iqtree_alrt",
        )
    with q4:
        st.checkbox("--asr", value=st.session_state.get("bt_iqtree_asr", False), key="bt_iqtree_asr")
    st.text_input(
        "iqtree_opts (append)",
        value=st.session_state.get("bt_iqtree_opts", ""),
        key="bt_iqtree_opts",
    )

    # Panaroo (visible if engine == Panaroo)
    if st.session_state.get("bt_pangenome_engine", "Panaroo") == "Panaroo":
        help_header("_Panaroo_", "panaroo", ratio=(3, 1))
        p1, p2, p3, p4 = st.columns(4)
        with p1:
            st.text_input(
                "--panaroo_mode",
                value=st.session_state.get("bt_panaroo_mode", ""),
                key="bt_panaroo_mode",
            )
        with p2:
            st.text_input(
                "--panaroo_alignment",
                value=st.session_state.get("bt_panaroo_alignment", ""),
                key="bt_panaroo_alignment",
            )
        with p3:
            st.text_input(
                "--panaroo_aligner",
                value=st.session_state.get("bt_panaroo_aligner", ""),
                key="bt_panaroo_aligner",
            )
        with p4:
            st.checkbox(
                "--merge_paralogs",
                value=st.session_state.get("bt_panaroo_merge_paralogs", False),
                key="bt_panaroo_merge_paralogs",
            )
        p5, p6, p7, p8 = st.columns(4)
        with p5:
            st.text_input(
                "--panaroo_core_threshold",
                value=st.session_state.get("bt_panaroo_core_threshold", ""),
                key="bt_panaroo_core_threshold",
            )
        with p6:
            st.text_input(
                "--panaroo_threshold",
                value=st.session_state.get("bt_panaroo_threshold", ""),
                key="bt_panaroo_threshold",
            )
        with p7:
            st.text_input(
                "--panaroo_family_threshold",
                value=st.session_state.get("bt_panaroo_family_threshold", ""),
                key="bt_panaroo_family_threshold",
            )
        with p8:
            st.text_input(
                "--len_dif_percent",
                value=st.session_state.get("bt_panaroo_len_dif_percent", ""),
                key="bt_panaroo_len_dif_percent",
            )
        st.text_input(
            "panaroo_opts (append)",
            value=st.session_state.get("bt_panaroo_opts", ""),
            key="bt_panaroo_opts",
        )

    # PIRATE (visible if engine == PIRATE)
    if st.session_state.get("bt_pangenome_engine", "Panaroo") == "PIRATE":
        help_header("_PIRATE_", "pirate", ratio=(3, 1))
        r1c, r2c, r3c, r4c = st.columns(4)
        with r1c:
            st.text_input(
                "--steps (e.g. 50,60,70,80,90,95,98)",
                value=st.session_state.get("bt_pirate_steps", ""),
                key="bt_pirate_steps",
            )
        with r2c:
            st.text_input(
                "--features (e.g. CDS)",
                value=st.session_state.get("bt_pirate_features", ""),
                key="bt_pirate_features",
            )
        with r3c:
            st.checkbox(
                "--para_off (disable paralog identification)",
                value=st.session_state.get("bt_pirate_para_off", False),
                key="bt_pirate_para_off",
            )
        with r4c:
            st.checkbox(
                "--z (keep intermediate files)",
                value=st.session_state.get("bt_pirate_z", False),
                key="bt_pirate_z",
            )
        st.text_input(
            "pan_opt (append for engine)",
            value=st.session_state.get("bt_pirate_opts", ""),
            key="bt_pirate_opts",
        )

    # Roary (visible if engine == Roary)
    if st.session_state.get("bt_pangenome_engine", "Panaroo") == "Roary":
        help_header("_Roary_", "roary", ratio=(3, 1))
        t1, t2, t3, t4 = st.columns(4)
        with t1:
            st.checkbox(
                "--use_prank",
                value=st.session_state.get("bt_roary_use_prank", False),
                key="bt_roary_use_prank",
            )
        with t2:
            st.text_input(
                "--i (identity %, e.g. 95)",
                value=st.session_state.get("bt_roary_i", ""),
                key="bt_roary_i",
            )
        with t3:
            st.text_input(
                "--cd (% core definition, e.g. 99)",
                value=st.session_state.get("bt_roary_cd", ""),
                key="bt_roary_cd",
            )
        with t4:
            st.text_input(
                "--g (max clusters, e.g. 50000)",
                value=st.session_state.get("bt_roary_g", ""),
                key="bt_roary_g",
            )
        u1, u2 = st.columns(2)
        with u1:
            st.checkbox(
                "--s (do not split paralogs)",
                value=st.session_state.get("bt_roary_s", False),
                key="bt_roary_s",
            )
        with u2:
            st.checkbox(
                "--ap (paralogs in core)",
                value=st.session_state.get("bt_roary_ap", False),
                key="bt_roary_ap",
            )
        st.text_input(
            "--iv (MCL inflation, e.g. 1.5)",
            value=st.session_state.get("bt_roary_iv", ""),
            key="bt_roary_iv",
        )

    # Prokka
    help_header("_Prokka (optional)_", "prokka", ratio=(3, 1))
    st.text_input(
        "--proteins (FASTA; optional)",
        value=st.session_state.get("bt_prokka_proteins", ""),
        key="bt_prokka_proteins",
    )
    st.text_input(
        "prokka_opts (append)",
        value=st.session_state.get("bt_prokka_opts", ""),
        key="bt_prokka_opts",
    )

    # Scoary & SNP-dists
    help_header("_Scoary & SNP-dists_", "scoary_snpdists", ratio=(3, 1))
    s1, s2, s3, s4 = st.columns(4)
    with s1:
        st.text_input(
            "--traits (CSV/TSV)",
            value=st.session_state.get("bt_scoary_traits", ""),
            key="bt_scoary_traits",
        )
    with s2:
        st.text_input(
            "--p_value_cutoff",
            value=st.session_state.get("bt_scoary_p_value_cutoff", ""),
            key="bt_scoary_p_value_cutoff",
        )
    with s3:
        st.text_input(
            "--correction",
            value=st.session_state.get("bt_scoary_correction", ""),
            key="bt_scoary_correction",
        )
    with s4:
        st.text_input(
            "--start_col",
            value=st.session_state.get("bt_scoary_start_col", ""),
            key="bt_scoary_start_col",
        )
    st.checkbox(
        "Scoary: --permute (permute phenotypes)",
        value=st.session_state.get("bt_scoary_permute", False),
        key="bt_scoary_permute",
    )
    st.checkbox("SNP-dists: --csv", value=st.session_state.get("bt_snpdists_csv", False), key="bt_snpdists_csv")

# --- Mashtree ---
if st.session_state.get("bt_run_mashtree"):
    help_header("**Mashtree â€” options**", "mashtree")
    c1, c2, c3, c4 = st.columns(4)
    with c1:
        st.number_input(
            "--trunclength",
            0,
            1000000,
            value=st.session_state.get("bt_mashtree_trunclength", 0),
            step=100,
            key="bt_mashtree_trunclength",
        )
    with c2:
        st.text_input(
            "--sortorder (e.g. avg)",
            value=st.session_state.get("bt_mashtree_sortorder", ""),
            key="bt_mashtree_sortorder",
        )
    with c3:
        st.number_input(
            "--genomesize",
            0,
            100000000,
            value=st.session_state.get("bt_mashtree_genomesize", 0),
            step=100000,
            key="bt_mashtree_genomesize",
        )
    with c4:
        st.number_input(
            "--mindepth",
            0,
            100,
            value=st.session_state.get("bt_mashtree_mindepth", 0),
            step=1,
            key="bt_mashtree_mindepth",
        )
    c5, c6 = st.columns(2)
    with c5:
        st.number_input(
            "--kmerlength",
            1,
            64,
            value=st.session_state.get("bt_mashtree_kmerlength", 21),
            step=1,
            key="bt_mashtree_kmerlength",
        )
    with c6:
        st.number_input(
            "--sketchsize",
            1,
            200000,
            value=st.session_state.get("bt_mashtree_sketchsize", 10000),
            step=100,
            key="bt_mashtree_sketchsize",
        )
    st.checkbox(
        "--save_sketches",
        value=st.session_state.get("bt_mashtree_save_sketches", False),
        key="bt_mashtree_save_sketches",
    )

# ------------------------- Include file and command assembly -------------------------

def write_include_file(outdir: str, samples: List[str]) -> str:
    """
    Generate a temporary file for `--include`, with one sample per line.

    Args:
        outdir (str): Base output directory.
        samples (List[str]): List of sample names to include.

    Returns:
        str: Path to the generated include file.
    """
    utils.ensure_state_dir()
    fname = APP_STATE_DIR / f"include_{hashlib.md5((outdir + '|' + ';'.join(samples)).encode()).hexdigest()[:10]}.txt"
    with open(fname, "w", encoding="utf-8") as fh:
        for s in samples:
            fh.write(s + "\n")
    return str(fname)

def bt_nextflow_cmd(
    tool: str,
    outdir: str,
    include_file: str,
    profile: str,
    threads: int | None = None,
    memory_gb: int | None = None,
    resume: bool = True,
    extra: List[str] | None = None,
) -> str:
    """
    Build the Nextflow command for a specific Bactopia Tool.

    Args:
        tool (str): Name of the tool (e.g., 'amrfinderplus').
        outdir (str): Bactopia results directory.
        include_file (str): Path to file with list of samples.
        profile (str): Nextflow profile (e.g., 'docker').
        threads (int | None): Max CPUs.
        memory_gb (int | None): Max memory in GB.
        resume (bool): Whether to use '-resume'.
        extra (List[str] | None): Additional arguments.

    Returns:
        str: The full shell command.
    """
    nf_bin = utils.get_nextflow_bin()
    base = [
        nf_bin,
        "run",
        "bactopia/bactopia",
        "-profile",
        profile,
        "--wf",
        tool,
        "--bactopia",
        outdir,
        "--include",
        include_file,
    ]
    if threads and threads > 0:
        base += ["--max_cpus", str(threads)]
    if memory_gb and memory_gb > 0:
        base += ["--max_memory", f"{memory_gb}.GB"]
    if resume:
        base += ["-resume"]
    if extra:
        base += extra
    if (st.session_state.get("bt_extra") or "").strip():
        base += shlex.split(st.session_state["bt_extra"])
    return " ".join(shlex.quote(x) for x in base)

# ------------------------- Action bar (async execution) -------------------------
st.divider()
col1, col2 = st.columns([1, 1])
with col1:
    start_tools = st.button(
        "â–¶ï¸ Run Tools",
        key="btn_tools_start",
        disabled=st.session_state.get("tools_running", False),
    )
with col2:
    stop_tools = st.button(
        "â¹ï¸ Stop",
        key="btn_tools_stop",
        disabled=not st.session_state.get("tools_running", False),
    )

status_box_tools = st.empty()
log_zone_tools = st.empty()

if stop_tools:
    utils.request_stop_ns("tools")
    status_box_tools.warning("Stop requestedâ€¦")

if start_tools:
    if not utils.nextflow_available():
        st.error("Nextflow not found (not in PATH, nor in BACTOPIA_ENV_PREFIX / NEXTFLOW_BIN / nextflow_bin).")
    else:
        if not bt_outdir:
            st.error("Define the 'Bactopia results folder'.")
        else:
            if not sel and samples:
                sel = samples
                st.session_state["bt_selected_samples"] = sel
            if not sel:
                st.error("Select at least one sample.")
            else:
                include_file = write_include_file(bt_outdir, sel)
                tools_to_run: List[tuple[str, List[str]]] = []

                # AMRFinderPlus
                if st.session_state.get("bt_run_amrfinderplus"):
                    extra: List[str] = []
                    if st.session_state.get("bt_amrfinderplus_plus"):
                        extra.append("--amrfinderplus_plus")
                    if st.session_state.get("bt_amrfinderplus_mutation_all"):
                        extra.append("--amrfinderplus_mutation_all")
                    v = st.session_state.get("bt_amrfinderplus_ident_min")
                    if v not in (None, ""):
                        extra += ["--amrfinderplus_ident_min", str(v)]
                    v = st.session_state.get("bt_amrfinderplus_coverage_min")
                    if v not in (None, ""):
                        extra += ["--amrfinderplus_coverage_min", str(v)]
                    v = (st.session_state.get("bt_amrfinderplus_organism", "")).strip()
                    if v:
                        extra += ["--amrfinderplus_organism", v]
                    if st.session_state.get("bt_amrfinderplus_report_common"):
                        extra.append("--amrfinderplus_report_common")
                    if st.session_state.get("bt_amrfinderplus_report_all_equal_best"):
                        extra.append("--amrfinderplus_report_all_equal_best")
                    if st.session_state.get("bt_amrfinderplus_allow_overlap"):
                        extra.append("--amrfinderplus_allow_overlap")
                    if st.session_state.get("bt_amrfinderplus_exclude_quick_need_prediction"):
                        extra.append("--amrfinderplus_exclude_quick_need_prediction")
                    v = (st.session_state.get("bt_amrfinderplus_extra", "")).strip()
                    if v:
                        extra += shlex.split(v)
                    tools_to_run.append(("amrfinderplus", extra))

                # RGI
                if st.session_state.get("bt_run_rgi"):
                    extra = []
                    if st.session_state.get("bt_rgi_use_diamond"):
                        extra.append("--rgi_use_diamond")
                    if st.session_state.get("bt_rgi_include_loose"):
                        extra.append("--rgi_include_loose")
                    if st.session_state.get("bt_rgi_exclude_nudge"):
                        extra.append("--rgi_exclude_nudge")
                    for k, flag in [
                        ("bt_rgi_frequency", "--rgi_frequency"),
                        ("bt_rgi_category", "--rgi_category"),
                        ("bt_rgi_cluster", "--rgi_cluster"),
                        ("bt_rgi_display", "--rgi_display"),
                    ]:
                        v = (st.session_state.get(k) or "").strip()
                        if v:
                            extra += [flag, v]
                    v = (st.session_state.get("bt_rgi_extra", "")).strip()
                    if v:
                        extra += shlex.split(v)
                    tools_to_run.append(("rgi", extra))

                # ABRicate
                if st.session_state.get("bt_run_abricate"):
                    extra = []
                    if (st.session_state.get("bt_abricate_db") or "").strip():
                        extra += ["--abricate_db", st.session_state["bt_abricate_db"]]
                    tools_to_run.append(("abricate", extra))

                # MobSuite
                if st.session_state.get("bt_run_mobsuite"):
                    tools_to_run.append(("mobsuite", []))

                # MLST
                if st.session_state.get("bt_run_mlst"):
                    extra = []
                    v = (st.session_state.get("bt_mlst_scheme", "")).strip()
                    if v:
                        extra += ["--scheme", v]
                    v = st.session_state.get("bt_mlst_minid")
                    if v not in (None, ""):
                        extra += ["--minid", str(v)]
                    v = st.session_state.get("bt_mlst_mincov")
                    if v not in (None, ""):
                        extra += ["--mincov", str(v)]
                    v = st.session_state.get("bt_mlst_minscore")
                    if v not in (None, ""):
                        extra += ["--minscore", str(v)]
                    if st.session_state.get("bt_mlst_nopath"):
                        extra.append("--nopath")
                    tools_to_run.append(("mlst", extra))

                # PlasmidFinder
                if st.session_state.get("bt_run_plasmidfinder"):
                    extra = []
                    v = st.session_state.get("bt_pf_mincov")
                    if v not in (None, ""):
                        extra += ["--pf_mincov", str(v)]
                    v = st.session_state.get("bt_pf_threshold")
                    if v not in (None, ""):
                        extra += ["--pf_threshold", str(v)]
                    v = (st.session_state.get("bt_plasmidfinder_extra", "")).strip()
                    if v:
                        extra += shlex.split(v)
                    tools_to_run.append(("plasmidfinder", extra))

                # Pangenome
                if st.session_state.get("bt_run_pangenome"):
                    extra = []

                    # Engine (Panaroo is default)
                    engine = st.session_state.get("bt_pangenome_engine", "Panaroo")
                    if engine == "PIRATE":
                        extra.append("--use_pirate")
                    elif engine == "Roary":
                        extra.append("--use_roary")

                    # Extra filters (âš ï¸ a second --include may overwrite the global include_file)
                    inc = (st.session_state.get("bt_pangenome_include") or "").strip()
                    exc = (st.session_state.get("bt_pangenome_exclude") or "").strip()
                    if inc:
                        extra += ["--include", inc]
                    if exc:
                        extra += ["--exclude", exc]

                    # NCBI genome download
                    species = (st.session_state.get("bt_pangenome_species") or "").strip()
                    accessions = (st.session_state.get("bt_pangenome_accessions") or "").strip()
                    if species:
                        extra += ["--species", species]
                    if accessions:
                        extra += ["--accessions", accessions]

                    # ClonalFrameML
                    if st.session_state.get("bt_pangenome_skip_recombination", False):
                        extra.append("--skip_recombination")

                    # IQ-TREE
                    v = (st.session_state.get("bt_iqtree_model", "")).strip()
                    if v:
                        extra += ["--iqtree_model", v]
                    v = st.session_state.get("bt_iqtree_bb", 0)
                    if v:
                        extra += ["--bb", str(int(v))]
                    v = st.session_state.get("bt_iqtree_alrt", 0)
                    if v:
                        extra += ["--alrt", str(int(v))]
                    if st.session_state.get("bt_iqtree_asr"):
                        extra.append("--asr")
                    v = (st.session_state.get("bt_iqtree_opts", "")).strip()
                    if v:
                        extra += ["--iqtree_opts", v]

                    # Panaroo params (only if engine == Panaroo)
                    if engine == "Panaroo":
                        for key, flag in [
                            ("bt_panaroo_mode", "--panaroo_mode"),
                            ("bt_panaroo_alignment", "--panaroo_alignment"),
                            ("bt_panaroo_aligner", "--panaroo_aligner"),
                            ("bt_panaroo_core_threshold", "--panaroo_core_threshold"),
                            ("bt_panaroo_threshold", "--panaroo_threshold"),
                            ("bt_panaroo_family_threshold", "--panaroo_family_threshold"),
                            ("bt_panaroo_len_dif_percent", "--len_dif_percent"),
                        ]:
                            vv = (st.session_state.get(key) or "").strip()
                            if vv:
                                extra += [flag, vv]
                        if st.session_state.get("bt_panaroo_merge_paralogs"):
                            extra.append("--merge_paralogs")
                        v = (st.session_state.get("bt_panaroo_opts", "")).strip()
                        if v:
                            extra += ["--panaroo_opts", v]

                    # PIRATE params
                    if engine == "PIRATE":
                        steps = (st.session_state.get("bt_pirate_steps") or "").strip()
                        features = (st.session_state.get("bt_pirate_features") or "").strip()
                        para_off = st.session_state.get("bt_pirate_para_off", False)
                        keep_z = st.session_state.get("bt_pirate_z", False)
                        pan_opt = (st.session_state.get("bt_pirate_opts") or "").strip()
                        if steps:
                            extra += ["--steps", steps]
                        if features:
                            extra += ["--features", features]
                        if para_off:
                            extra.append("--para_off")
                        if keep_z:
                            extra.append("--z")
                        if pan_opt:
                            extra += ["--pan_opt", pan_opt]

                    # Roary params
                    if engine == "Roary":
                        if st.session_state.get("bt_roary_use_prank"):
                            extra.append("--use_prank")
                        for key, flag in [
                            ("bt_roary_i", "--i"),
                            ("bt_roary_cd", "--cd"),
                            ("bt_roary_g", "--g"),
                            ("bt_roary_iv", "--iv"),
                        ]:
                            vv = (st.session_state.get(key) or "").strip()
                            if vv:
                                extra += [flag, vv]
                        if st.session_state.get("bt_roary_s"):
                            extra.append("--s")
                        if st.session_state.get("bt_roary_ap"):
                            extra.append("--ap")

                    # Prokka
                    v = (st.session_state.get("bt_prokka_proteins", "")).strip()
                    if v:
                        extra += ["--proteins", v]
                    v = (st.session_state.get("bt_prokka_opts", "")).strip()
                    if v:
                        extra += ["--prokka_opts", v]

                    # Scoary & SNP-dists
                    v = (st.session_state.get("bt_scoary_traits", "")).strip()
                    if v:
                        extra += ["--traits", v]
                    for key, flag in [
                        ("bt_scoary_p_value_cutoff", "--p_value_cutoff"),
                        ("bt_scoary_correction", "--correction"),
                        ("bt_scoary_start_col", "--start_col"),
                    ]:
                        vv = (st.session_state.get(key) or "").strip()
                        if vv:
                            extra += [flag, vv]
                    if st.session_state.get("bt_scoary_permute"):
                        extra += ["--permute"]
                    if st.session_state.get("bt_snpdists_csv"):
                        extra += ["--csv"]

                    tools_to_run.append(("pangenome", extra))

                # Mashtree
                if st.session_state.get("bt_run_mashtree"):
                    extra = []
                    for key, flag in [
                        ("bt_mashtree_trunclength", "--trunclength"),
                        ("bt_mashtree_sortorder", "--sortorder"),
                        ("bt_mashtree_genomesize", "--genomesize"),
                        ("bt_mashtree_mindepth", "--mindepth"),
                        ("bt_mashtree_kmerlength", "--kmerlength"),
                        ("bt_mashtree_sketchsize", "--sketchsize"),
                    ]:
                        vv = st.session_state.get(key)
                        if isinstance(vv, (int, float)) and vv > 0:
                            extra += [flag, str(vv)]
                        elif isinstance(vv, str) and vv.strip():
                            extra += [flag, vv.strip()]
                    if st.session_state.get("bt_mashtree_save_sketches"):
                        extra.append("--save_sketches")
                    tools_to_run.append(("mashtree", extra))

                if not tools_to_run:
                    st.warning("Select at least one official tool.")
                else:
                    sub_cmds = []
                    stdbuf = shutil.which("stdbuf")
                    for tool, extra in tools_to_run:
                        cmdi = bt_nextflow_cmd(
                            tool,
                            bt_outdir,
                            include_file,
                            st.session_state.get("bt_profile", "docker"),
                            st.session_state.get("bt_threads") or None,
                            st.session_state.get("bt_memory_gb") or None,
                            resume=st.session_state.get("bt_resume", True),
                            extra=extra,
                        )
                        if stdbuf:
                            cmdi = f"{stdbuf} -oL -eL {cmdi}"
                        sub_cmds.append(f'echo "===== [Bactopia Tool] {tool} =====" ; {cmdi}')
                    full_cmd = " ; ".join(sub_cmds)
                    status_box_tools.info("Running tools (async).")
                    utils.start_async_runner_ns(full_cmd, "tools")

# Real-time log update
if st.session_state.get("tools_running", False):
    utils.drain_log_queue_ns("tools", tail_limit=500, max_pull=800)
    utils.render_log_box_ns("tools", height=520)
    finished = utils.check_status_and_finalize_ns("tools", status_box_tools)
    if not finished:
        time.sleep(0.3)
        utils._st_rerun()
else:
    utils.render_log_box_ns("tools", height=520)

# ------------------------- merged-results -------------------------
st.divider()
st.subheader("merged-results (recent runs)")

runs_root = pathlib.Path(bt_outdir) / "bactopia-runs" if bt_outdir else None
if runs_root and runs_root.exists():
    runs = sorted(runs_root.glob("*"))
    if runs:
        latest = runs[-1]
        mr = latest / "merged-results"
        if mr.exists():
            for f in sorted(mr.glob("*.tsv")):
                st.markdown(f"- `{f.name}` â€” {f}")
        else:
            st.caption("No merged-results found in this run.")
    else:
        st.caption("There are no runs in bactopia-runs yet.")
else:
    st.caption("bactopia-runs directory not found.")

DISCLAIMER_MD = """
> âš ï¸ **Notice about Bactopia**
>
> This panel only orchestrates official **Bactopia** pipeline.  
> Bactopia is software developed by third parties (https://bactopia.github.io/latest/).  
> **BEAR-HUB** does not modify Bactopia's code; it only assembles commands
> and parameters in a more user-friendly way.
>
> For methods, limitations, and the correct way to cite Bactopia, always refer
> to the official documentation and repository.
"""

st.markdown(DISCLAIMER_MD)
